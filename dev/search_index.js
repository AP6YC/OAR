var documenterSearchIndex = {"docs":
[{"location":"examples/tutorials/mushroom/#mushroom","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"","category":"section"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/tutorials/mushroom/#Overview","page":"Mushroom Dataset","title":"Overview","text":"","category":"section"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"This example shows how to do supervised training and testing with START on the UCI Mushroom dataset. The Mushroom dataset is a purely categorical dataset where each feature has entries that are members of different discrete categories. Where this is normally a challenge for other machine learning models due to encoding schemes and considerations, START learns directly on the symbols of the dataset itself. Furthermore, START can use a simple supervised mode to map clusters to supervised categories to allow for training and performance testing.","category":"page"},{"location":"examples/tutorials/mushroom/#Setup","page":"Mushroom Dataset","title":"Setup","text":"","category":"section"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"First, we load some dependencies:","category":"page"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"# Just load this project\nusing OAR","category":"page"},{"location":"examples/tutorials/mushroom/#Loading-the-Dataset","page":"Mushroom Dataset","title":"Loading the Dataset","text":"","category":"section"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"The OAR project has an all-in-one function for loading the dataset, parsing it into statements, and inferring the resulting grammar:","category":"page"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"# Point to the relative file location\nfilename = joinpath(\"..\", \"assets\", \"mushrooms.csv\")\n# All-in-one function\nfs, bnf = OAR.symbolic_mushroom(filename)","category":"page"},{"location":"examples/tutorials/mushroom/#Intializing-START","page":"Mushroom Dataset","title":"Intializing START","text":"","category":"section"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"We use the grammar and keyword arguments to set the options of the module during initialization:","category":"page"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"# Initialize the module with options\nart = OAR.GramART(bnf,\n    rho = 0.6,\n)","category":"page"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"We could also set or change the options after initialization with art.opts.rho = 0.7.","category":"page"},{"location":"examples/tutorials/mushroom/#Training-and-Testing","page":"Mushroom Dataset","title":"Training and Testing","text":"","category":"section"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"To train the model we will use the training statements portion of the dataset that we loaded earlier along with their corresponding supervisory labels:","category":"page"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"# Iterate over the training data\nfor ix in eachindex(fs.train_x)\n    statement = fs.train_x[ix]\n    label = fs.train_y[ix]\n    OAR.train!(\n        art,\n        statement,\n        y=label,\n    )\nend","category":"page"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"To test the model, we use the testing data and extract the prescribed label for each sample by the model:","category":"page"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"# Create a container for the output labels\nclusters = zeros(Int, length(fs.test_y))\n# Iterate over the testing data\nfor ix in eachindex(fs.test_x)\n    clusters[ix] = OAR.classify(\n        art,\n        fs.test_x[ix],\n        get_bmu=true,\n    )\nend","category":"page"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"We can finally test the performance of the module by seeing the percentage of testing samples that are incorrectly labeled:","category":"page"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"# Calculate testing performance\nperf = OAR.AdaptiveResonance.performance(fs.test_y, clusters)\n\n# Logging\n@info \"Final performance: $(perf)\"\n@info \"n_categories: $(art.stats[\"n_categories\"])\"","category":"page"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"","category":"page"},{"location":"examples/tutorials/mushroom/","page":"Mushroom Dataset","title":"Mushroom Dataset","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"man/languages/#languages","page":"Languages","title":"Languages","text":"","category":"section"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"This project has both Julia, Python, and Rust code, so files and experiments using each of these languages are listed separately.","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"Julia: an outline of the main julia component of the project.\nTesting: how julia unit tests work in the project.\nDocumentation: how this very documentation is generated and hosted with julia and Documenter.jl\nPython: how the various python components of the project work, including notebooks, scripts, and their requirements.\nRust: where the rust component of the project is located and how to run it.","category":"page"},{"location":"man/languages/#man-julia","page":"Languages","title":"Julia","text":"","category":"section"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"The Julia (usage documentation here) component of this repository is implemented as a DrWatson project, so the repo structure and experiment usage generally follows the DrWatson philosophy with some minor changes:","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"Experiments are enumerated in their own folders under scripts.\nDatasets for experiments and the destination for subsequent results are under work.","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"This repo is also structured as its own Julia module with common code under src/. As such, most experiments begin with the following preamble to load Revise and OAR:","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"using Revise\nusing OAR","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"Revise.jl is used here because it affords the ability to change functions and modules in scripts without having to reload the Julia session every time that a change is made. OAR is loaded as its own module because it contains most of the driver code for experiments.","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"Some other experiments follow the DrWatson usage with the following preamble, which initializes DrWatson and loads the OAR libary code:","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"using DrWatson\n@quickactivate :OAR","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"The @quickactivate macro simply makes sure that the activate project is the OAR project and loads it. This usage is only necessary if running the experiment from some directory outside the project, but the assumption is made for most experiments that the script is run from the top of the OAR project","category":"page"},{"location":"man/languages/#man-julia-testing","page":"Languages","title":"Testing","text":"","category":"section"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"Some unit tests are written to validate the library code used for experiments. Testing is done in the usual Julia workflow through the Julia REPL:","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"julia> ]\n(@v1.9) pkg> activate .\n(OAR) pkg> test","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"These unit tests are also automated through GitHub workflows.","category":"page"},{"location":"man/languages/#man-julia-documentation","page":"Languages","title":"Documentation","text":"","category":"section"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"The Documenter.jl package is used to generate documentation with examples being generated with DemoCards.jl. This documentation is generated and hosted with GitHub workflows for the project. To generate the documentation locally, change your terminal directory to the docs/ directory and run Julia with the following REPL commands:","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"julia> ]\n(@v1.9) pkg> activate .\n(docs) pkg> instantiate\n(docs) pkg> <BACKSPACE>\njulia> include(\"serve\".jl)","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"The line <BACKSPACE> means hitting the backspace key on your keyboard. This instantiates the documentation (downloading and precompiling dependencies), builds the documentation, and hosts it locally. If you wish to just build the docs, instead run include(\"make.jl\") (the serve.jl script simply runs the make script and runs a local live server for convenience).","category":"page"},{"location":"man/languages/#man-python","page":"Languages","title":"Python","text":"","category":"section"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"Python (usage docs here) experiments are currently in the form of IPython Jupyter notebooks under the notebooks/ folder. Pip requirements are listed in requirements.txt, and Python 3.11 is used.","category":"page"},{"location":"man/languages/#man-rust","page":"Languages","title":"Rust","text":"","category":"section"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"The Rust (usage docs here) component of the project is contained with its own oar/ folder. Until the Rust component becomes more sophisticated, its usage simply follows the usual binary project compile-execute method with cargo run:","category":"page"},{"location":"man/languages/","page":"Languages","title":"Languages","text":"cd oar\ncargo run","category":"page"},{"location":"man/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"This page serves as the contribution guide for the OAR package. From top to bottom, the ways of contributing are:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"GitHub Issues: how to raise an issue with the project.\nJulia Development: how to download and interact with the package.\nGitFlow: how to directly contribute code to the package in an organized way on GitHub.\nDevelopment Details: how the internals of the package are currently setup if you would like to directly contribute code.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Please also see the Attribution to learn about the authors and sources of support for the project.","category":"page"},{"location":"man/contributing/#Issues","page":"Contributing","title":"Issues","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The main point of contact is the GitHub issues page for the project. This is the easiest way to contribute to the project, as any issue you find or request you have will be addressed there by the authors of the package. Depending on the issue, the authors will collaborate with you, and after making changes they will link a pull request which addresses your concern or implements your proposed changes.","category":"page"},{"location":"man/contributing/#Julia-Development","page":"Contributing","title":"Julia Development","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"As a Julia package, development follows the usual procedure:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Clone the project from GitHub\nSwitch to or create the branch that you wish work on (see GitFlow).\nStart Julia at your development folder.\nInstantiate the package (i.e., download and install the package dependencies).","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"For example, you can get the package and startup Julia with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"git clone git@github.com:AP6YC/OAR.jl.git\njulia --project=.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIn Julia, you must activate your project in the current REPL to point to the location/scope of installed packages. The above immediately activates the project when starting up Julia, but you may also separately startup the julia and activate the package with the interactive package manager via the ] syntax:julia\njulia> ]\n(@v1.8) pkg> activate .\n(OAR) pkg>","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"You may run the package's unit tests after the above setup in Julia with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"julia> using Pkg\njulia> Pkg.instantiate()\njulia> Pkg.test()","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"or interactively though the Julia package manager with","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"julia> ]\n(OAR) pkg> instantiate\n(OAR) pkg> test","category":"page"},{"location":"man/contributing/#GitFlow","page":"Contributing","title":"GitFlow","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The OAR package follows the GitFlow git working model. The original post by Vincent Driessen outlines this methodology quite well, while Atlassian has a good tutorial as well. In summary:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"Create a feature branch off of the develop branch with the name feature/<my-feature-name>.\nCommit your changes and push to this feature branch.\nWhen you are satisfied with your changes, initiate a GitHub pull request (PR) to merge the feature branch with develop.\nIf the unit tests pass, the feature branch will first be merged with develop and then be deleted.\nReleases will be periodically initiated from the develop branch and versioned onto the master branch.\nImmediate bug fixes circumvent this process through a hotfix branch off of master.","category":"page"},{"location":"man/contributing/#Development-Details","page":"Contributing","title":"Development Details","text":"","category":"section"},{"location":"man/contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"These docs are currently hosted as a static site on the GitHub pages platform. They are setup to be built and served in a separate branch called gh-pages from the master/development branches of the project.","category":"page"},{"location":"man/contributing/#Package-Structure","page":"Contributing","title":"Package Structure","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"The OAR package has the following file structure:","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"OAR\n├── .github/workflows       // GitHub: workflows for testing and documentation.\n├── cluster                 // HPC: scripts and submission files for clusters.\n├── dockerfiles             // Docker: dockerfiles for experiment reproducibility.\n├── docs                    // Docs: documentation for the module.\n│   └───src                 //      Documentation source files.\n├── notebooks               // Source: experiment notebooks.\n├── oar                     // Source: Rust component of the project.\n├── opts                    // Config: options and experiment configurations.\n├── scripts                 // Source: experiment scripts.\n├── src                     // Source: majority of source code.\n│   └───lib                 //      Library for the OAR module.\n│       └───grammar         //      Grammar code implementions.\n├── test                    // Test: Unit, integration, and environment tests.\n├── work                    // Data: datasets, results, plots, etc.\n│   ├───data                //      Source datasets for experiments.\n│   └───results             //      Destination for generated figures, etc.\n├── .gitattributes          // Git: LFS settings, languages, etc.\n├── .gitignore              // Git: .gitignore for the whole project.\n├── CODE_OF_CONDUCT.md      // Doc: the code of conduct for contributors.\n├── CONTRIBUTING.md         // Doc: contributing guide (points to this page).\n├── LICENSE                 // Doc: the license to the project.\n├── Project.toml            // Julia: the Pkg.jl dependencies of the project.\n└── README.md               // Doc: the top-level readme for the project.","category":"page"},{"location":"man/contributing/#Type-Aliases","page":"Contributing","title":"Type Aliases","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"For convenience in when defining types and function signatures, this package uses the NumericalTypeAliases.jl package and the aliases therein. The documentation for the abstract and concrete types provided by NumericalTypeAliases.jl can be found here.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"In this package, data samples are always Real-valued, whereas class labels are integered. Furthermore, independent class labels are always Int because of the Julia native support for a given system's signed native integer type.","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"This project does not currently test for the support of arbitrary precision arithmetic because learning algorithms in general do not have a significant need for precision.","category":"page"},{"location":"man/contributing/#Attribution","page":"Contributing","title":"Attribution","text":"","category":"section"},{"location":"man/contributing/#Authors","page":"Contributing","title":"Authors","text":"","category":"section"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"This package is developed and maintained by Sasha Petrenko with sponsorship by the Applied Computational Intelligence Laboratory (ACIL).","category":"page"},{"location":"man/contributing/","page":"Contributing","title":"Contributing","text":"If you simply have suggestions for improvement, Sasha Petrenko (<petrenkos@mst.edu>) is the current developer and maintainer of the OAR package, so please feel free to reach out with thoughts and questions.","category":"page"},{"location":"examples/tutorials/lerche/#lerche","page":"Lerche Parsing","title":"Lerche Parsing","text":"","category":"section"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/tutorials/lerche/#Overview","page":"Lerche Parsing","title":"Overview","text":"","category":"section"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"This example shows how the the Lerche.jl parsing library works, which provides the necessary machinery to define lark-like grammars and parse statements into arbitrary Julia structures to interface with the GramART tools in this project. These tools are demonstrated on the how to parse approximate symbolic statements of the real-valued Iris dataset back into a tree that can be used in GramART.","category":"page"},{"location":"examples/tutorials/lerche/#Setup","page":"Lerche Parsing","title":"Setup","text":"","category":"section"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"First, we load some dependencies:","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"using OAR       # The OAR project module\nusing Lerche    # Parsing library","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"Next, we declare the rules of the symbolic Iris grammar using the syntax and format provided by the Leche library and the lark Python library that it is inspired by.","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"# Statements in this grammar are simply four nonterminal positions with four bins of terminals.\niris_grammar = raw\"\"\"\n    ?start: statement\n\n    statement: sl sw pl pw\n\n    sl : SL -> iris_symb\n    sw : SW -> iris_symb\n    pl : PL -> iris_symb\n    pw : PW -> iris_symb\n\n    SL : /SL[1-9]?[0-9]?/\n    SW : /SW[1-9]?[0-9]?/\n    PL : /PL[1-9]?[0-9]?/\n    PW : /PW[1-9]?[0-9]?/\n\n    %import common.WS\n    %ignore WS\n\"\"\"","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"Next, we set up the parsing transformer and its rules for transforming the symbols that the parser encounters into Julia datatypes.","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"# The grammar tree subtypes from a Lerche Transformer\nstruct GramARTTree <: Transformer end\n\n# The rules turn the terminals into `OAR` grammar symbols and statements into vectors\n@rule iris_symb(t::GramARTTree, p) = OAR.GSymbol{String}(p[1], true)\n@rule statement(t::GramARTTree, p) = Vector(p)","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"Finally, we create the parser from these rules:","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"# Create the Lark parser from the grammar, transformer, and additional settings\niris_parser = Lark(\n    iris_grammar,\n    parser=\"lalr\",\n    lexer=\"standard\",\n    transformer=GramARTTree()\n);\nnothing #hide","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"We can then set some sample text as the input statement:","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"text = raw\"SL1 SW3 PL4 PW8\"","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"And we parse the statement, seeing that we indeed get a vector of of OAR.GSymbols:","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"k = Lerche.parse(iris_parser, text)","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"","category":"page"},{"location":"examples/tutorials/lerche/","page":"Lerche Parsing","title":"Lerche Parsing","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"man/guide/#Package-Guide","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"To work with the OAR project, you should know:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"How to install the package\nAn overview of the project\nHow to run experiments","category":"page"},{"location":"man/guide/#installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Because it is an experimental research repository, the OAR package is not registered on JuliaHub. To set Julia component the project up, you must:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Download a Julia distribution and install it on your system\nGit clone this repository or download a zip.\nRun julia within the top of the OAR directory, and run the following commands to instantiate the package:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"julia> ]\n(@v1.9) pkg> activate .\n(OAR) pkg> instantiate","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"This will download all of the dependencies of the project and precompile where possible.","category":"page"},{"location":"man/guide/#guide-overview","page":"Guide","title":"Overview","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The OAR project is mainly a Julia programming language research project, so it is not designed as a package for use and installation through JuliaHub as other packages are. However, the main driver libraries of the project are bundled into a OAR module, so this module is loaded in the preamble of all experiments as a concise way of loading common code.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"The project utilizes DrWatson for workflow utilities such as directory operations, results saving/loading, and simulation configurations. The file structure of this project differs slightly from the DrWatson default setup, so extra utilities are used for pointing to the correct source data directory and destination results directory according to each experiment.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"In addition to the Julia components, some experiments are written in Python and Rust.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Each experiment contains a README outlining the setup and usage of the experiment such as in the setup of custom Python environments and in the running of parallel and distibuted experiments.","category":"page"},{"location":"man/guide/#guide-experiments","page":"Guide","title":"Experiments","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"To run an Julia experiment, setup the OAR project on your target system and run the experiment either in an interactive session with include(...):","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"include(\"scripts/1_iris/gramart.jl\")","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"or from a terminal command line (from the top of the project directory):","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"julia --project=. scripts/1_iris/gramart.jl","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"note: Note\nThis project is still under development, so detailed usage guides beyond this have not yet been written about the project's functionality. Please see the other sections of this documentation for examples, definition indices, and more.","category":"page"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section contains some examples using the OAR package with topics ranging from how to the internals of package work to practical examples on different datasets.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples are separated into the following sections:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Tutorials: basic Julia examples that also include how low-level routines work in this package.\nExperiments: how to run experiments in the package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#Tutorials","page":"Examples","title":"Tutorials","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples demonstrate some low-level usage of the Julia programming language and subroutines of the OAR project itself.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"grid-card-section\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo provides a quick example of how to load the Iris dataset with existing Julia tools.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Iris Dataset","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo provides a quick example of how to load the Iris dataset with existing Julia tools.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Lerche Parsing","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo provides an example of how to do simple supervised training and testing on the UCI Mushroom dataset.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Mushroom Dataset","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/#Experiments","page":"Examples","title":"Experiments","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples show how to run experiments in the OAR project.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"grid-card-section\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo demonstrates how to utilize a GramART module on a basic dataset.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"GramART","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo demonstrates how to utilize a GramART module on knowledge graph dataset.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Clustering on Knowledge Graphs","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This demo shows how to run a simple experiment in the OAR project.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simple Experiment","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#examples-attribution","page":"Examples","title":"Attribution","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Icons used for the covers of these demo cards are attributed to the following sites:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Lab icons created by Prosymbols - Flaticon (experiment_748518)\nIris icons created by Freepik - Flaticon (iris_4139395)\nGrammar icons created by Freepik - Flaticon (grammar_6749514)\nParsing icons created by Flat Icons - Flaticon (parse_3344356)\nKnowledge icons created by Freepik - Flaticon (knowledge_3930428)\nMushroom icons created by Freepik - Flaticon (mushroom_616593)","category":"page"},{"location":"examples/experiments/kg/#kg","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"","category":"section"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/experiments/kg/#Overview","page":"Clustering on Knowledge Graphs","title":"Overview","text":"","category":"section"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"This script demonstrates the usage of a GramART module for analyzing biomedical data knowledge graphs. Though the OAR project contains multiple such knowledge graphs, the Charcot-Marie-Tooth (CMT) dataset is used as an example here with the procedure remaining the same with other datasets.","category":"page"},{"location":"examples/experiments/kg/#Setup","page":"Clustering on Knowledge Graphs","title":"Setup","text":"","category":"section"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"First, we load some dependencies:","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"# Import the OAR project module\nusing OAR","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"Next, we must should point to the location of the dataset containing the preprocessed knowledge graph statements","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"# Location of the edge attributes file, formatted for Lerch parsing\nedge_file = joinpath(\"..\", \"assets\", \"edge_attributes_lerche.txt\")","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"Load the KG statements","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"statements = OAR.get_kg_statements(edge_file)","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"Generate a simple subject-predicate-object grammar from the statements","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"grammar = OAR.SPOCFG(statements)","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"Initialize the GramART module","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"gramart = OAR.GramART(\n    grammar,\n    rho=0.05,\n    terminated=false,\n)","category":"page"},{"location":"examples/experiments/kg/#Train","page":"Clustering on Knowledge Graphs","title":"Train","text":"","category":"section"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"Now we are ready to cluster the statements. We do this with the train! function without supervised labels, indicating that we are learning on the samples alone.","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"# Process the statements\nfor statement in statements\n    OAR.train!(gramart, statement)\nend","category":"page"},{"location":"examples/experiments/kg/#Analysis","page":"Clustering on Knowledge Graphs","title":"Analysis","text":"","category":"section"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"We can see how the clustering went by inspecting how many clusters we generated:","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"@info \"Number of categories: $(length(gramart.protonodes))\"","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"","category":"page"},{"location":"examples/experiments/kg/","page":"Clustering on Knowledge Graphs","title":"Clustering on Knowledge Graphs","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"examples/tutorials/iris/#iris","page":"Iris Dataset","title":"Iris Dataset","text":"","category":"section"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/tutorials/iris/#Overview","page":"Iris Dataset","title":"Overview","text":"","category":"section"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"This example shows how the Iris dataset is loaded and used with existing Julia tools within the OAR project, which can be adapted for other Julia projects. Other scripts within this project utilize higher-level functions for loading, transforming, and splitting the data automatically, and this example shows how this is done at a low-level.","category":"page"},{"location":"examples/tutorials/iris/#Setup","page":"Iris Dataset","title":"Setup","text":"","category":"section"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"First, we load some dependencies:","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"# Multi-line using statements are permitted in Julia to gather all requirements and compile at once\nusing\n    OAR,                # This project\n    MLDatasets,         # Iris dataset\n    MLUtils             # Data utilities, splitting, etc.","category":"page"},{"location":"examples/tutorials/iris/#Loading-the-Dataset","page":"Iris Dataset","title":"Loading the Dataset","text":"","category":"section"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"We will download the Iris dataset for its small size and benchmark use for clustering algorithms.","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"iris = Iris()","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"Next, we manipulate the features and labels into a matrix of features and a vector of labels","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"features, labels = Matrix(iris.features)', vec(Matrix{String}(iris.targets))","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"Because the MLDatasets package gives us Iris labels as strings, we need to get a list of integers representing each class:","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"labels = OAR.integer_encoding(labels)\nunique(labels)","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"Next, we will create a train/test split:","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"(X_train, y_train), (X_test, y_test) = splitobs((features, labels))","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"We now have a train/test split of the features and targets for the Iris dataset. This project also defines some low-level data utilities for more easily passing around and transforming this data, so we often see this train/test split as a combined DataSplit struct:","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"data = OAR.DataSplit(X_train, X_test, y_train, y_test)","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"We can also turn this DataSplit into a vectored variant (where the features are arranged as a vector of samples rather than combined into a matrix like in the DataSplit):","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"data_vec = OAR.VectoredDataSplit(data)","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"","category":"page"},{"location":"examples/tutorials/iris/","page":"Iris Dataset","title":"Iris Dataset","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"examples/experiments/gramart/#gramart","page":"GramART","title":"GramART","text":"","category":"section"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/experiments/gramart/#Overview","page":"GramART","title":"Overview","text":"","category":"section"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"This example demonstrates the usage of a GramART module. This module is tested on a modified symbolic Iris dataset as a proof of concept, but it is capable of working on arbitrary symbolic datasets.","category":"page"},{"location":"examples/experiments/gramart/#Setup","page":"GramART","title":"Setup","text":"","category":"section"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"First, we load some dependencies:","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"# Import the OAR project module\nusing OAR","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"Next, we can load the Iris dataset in a modified symbolic form:","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"# All-in-one function\nfs, bnf = OAR.symbolic_iris()","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"We can finally initialize the GramART module using the grammar that we have describing the symbolic Iris dataset:","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"# Initialize the GramART module\ngramart = OAR.GramART(bnf)","category":"page"},{"location":"examples/experiments/gramart/#Training","page":"GramART","title":"Training","text":"","category":"section"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"Now that we have a GramART module, we should process the training dataset:","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"# Cluster the statements\nfor statement in fs.train_x\n    OAR.train!(gramart, statement)\nend","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"In fact, we can also do a simple supervised version of the training if labels are available. Let's do that with another module:","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"# Initialize the GramART module\ngramart_supervised = OAR.GramART(bnf)\n# Set the vigilance low for generalization\ngramart_supervised.opts.rho = 0.05\n# Train in supervised mode\nfor ix in eachindex(fs.train_x)\n    sample = fs.train_x[ix]\n    label = fs.train_y[ix]\n    OAR.train!(gramart_supervised, sample, y=label)\nend","category":"page"},{"location":"examples/experiments/gramart/#Analysis","page":"GramART","title":"Analysis","text":"","category":"section"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"Now let's see what's inside the first module:","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"# Inspect the module\n@info \"Number of categories: $(length(gramart.protonodes))\"","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"We can also see how the supervised training went by classifying the test data and computing the performance:","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"# Classification\ny_hat = zeros(Int, length(fs.test_y))\nfor ix in eachindex(fs.test_x)\n    sample = fs.test_x[ix]\n    y_hat[ix] = OAR.classify(gramart_supervised, sample, get_bmu=true)\nend\n\n# Calculate performance\nperf = OAR.AdaptiveResonance.performance(y_hat, fs.test_y)\n@info \"Supervised testing performance: $(perf)\"","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"","category":"page"},{"location":"examples/experiments/gramart/","page":"GramART","title":"GramART","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"examples/experiments/simple_experiment/#simple_experiment","page":"Simple Experiment","title":"Simple Experiment","text":"","category":"section"},{"location":"examples/experiments/simple_experiment/","page":"Simple Experiment","title":"Simple Experiment","text":"(Image: Source code) (Image: notebook) (Image: compat) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/experiments/simple_experiment/#Overview","page":"Simple Experiment","title":"Overview","text":"","category":"section"},{"location":"examples/experiments/simple_experiment/","page":"Simple Experiment","title":"Simple Experiment","text":"This example shows how to run the Julia experiments in the OAR project. Experiments in the Julia component of the project are implemented as Julia scripts that load the OAR module as a source library and subsequently implement a particular experiment.","category":"page"},{"location":"examples/experiments/simple_experiment/","page":"Simple Experiment","title":"Simple Experiment","text":"These experiments are enumerated under the scripts/ folder with a number and shorthand name for the experiment. READMEs populate this directory to provide context, explanation, and instructions for each experiment.","category":"page"},{"location":"examples/experiments/simple_experiment/","page":"Simple Experiment","title":"Simple Experiment","text":"You may run one of these experiments by initiating a Julia REPL and \"including\" the script (which simply inserts the contents of the script directly into the session and runs it). This example points to the relative location of an experiment with respect to this example file, so you may need to adjust how you reference the experiment:","category":"page"},{"location":"examples/experiments/simple_experiment/","page":"Simple Experiment","title":"Simple Experiment","text":"# Include/run an experiment that generates a random statement from a discretized Iris dataset grammar\ninclude(joinpath(\"..\", \"..\", \"..\", \"..\", \"scripts\", \"0_init\", \"ebnf.jl\"))","category":"page"},{"location":"examples/experiments/simple_experiment/","page":"Simple Experiment","title":"Simple Experiment","text":"The above script very importantly includes the preamble","category":"page"},{"location":"examples/experiments/simple_experiment/","page":"Simple Experiment","title":"Simple Experiment","text":"# using DrWatson\n# @quickactivate :OAR","category":"page"},{"location":"examples/experiments/simple_experiment/","page":"Simple Experiment","title":"Simple Experiment","text":"which makes sure that the correct context is set up and that the OAR module containing experiment driver code is precompiled. This example will now reactivate the docs package because running the above example activates the top-level OAR package.","category":"page"},{"location":"examples/experiments/simple_experiment/","page":"Simple Experiment","title":"Simple Experiment","text":"# Reactivate the documentation for future examples\nusing Pkg\nPkg.activate(joinpath(\"..\", \"..\", \"..\", \"..\", \"docs\"))","category":"page"},{"location":"examples/experiments/simple_experiment/","page":"Simple Experiment","title":"Simple Experiment","text":"","category":"page"},{"location":"examples/experiments/simple_experiment/","page":"Simple Experiment","title":"Simple Experiment","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"man/dev-index/#dev-main-index","page":"Dev Index","title":"Developer Index","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"This page lists the types and functions that are internal to the OAR package. Because they are not part of the public API, these names might change relatively frequently between versions and so should not be relied upon.","category":"page"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"All internal names are listed in the Index, and each of these entries link to the docstrings in the Docs section.","category":"page"},{"location":"man/dev-index/#dev-index-toc","page":"Dev Index","title":"\"Table\" of Contents","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"Modules Functions Types Constants\nIndex Index Index Index\nDocs Docs Docs Docs","category":"page"},{"location":"man/dev-index/#dev-index","page":"Dev Index","title":"Index","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"This section contains a list of internal names that link to their corresponding Documentation.","category":"page"},{"location":"man/dev-index/#dev-index-modules","page":"Dev Index","title":"Modules","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"Pages   = [\"dev-index.md\"]\nModules = [OAR]\nOrder   = [:module]","category":"page"},{"location":"man/dev-index/#dev-index-functions","page":"Dev Index","title":"Functions","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"Pages   = [\"dev-index.md\"]\nModules = [OAR]\nOrder   = [:function]","category":"page"},{"location":"man/dev-index/#dev-index-types","page":"Dev Index","title":"Types","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"Pages   = [\"dev-index.md\"]\nModules = [OAR]\nOrder   = [:type]","category":"page"},{"location":"man/dev-index/#dev-index-constants","page":"Dev Index","title":"Constants","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"Pages   = [\"dev-index.md\"]\nModules = [OAR]\nOrder   = [:constant]","category":"page"},{"location":"man/dev-index/#dev-index-docs","page":"Dev Index","title":"Docs","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"Documentation for all internal names are listed below.","category":"page"},{"location":"man/dev-index/#dev-index-modules-docs","page":"Dev Index","title":"Modules","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"Modules = [OAR]\nPublic  = false\nOrder   = [:module]","category":"page"},{"location":"man/dev-index/#dev-index-functions-docs","page":"Dev Index","title":"Functions","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"Modules = [OAR]\nPublic  = false\nOrder   = [:function]","category":"page"},{"location":"man/dev-index/#Base.show-Tuple{IO, Lerche.Lark}","page":"Dev Index","title":"Base.show","text":"show(io::IO, parser::Lerche.Lark) -> Any\n\n\nSummary\n\nOverload of the show function for Lerche.Lark parsers to reduce terminal output noise.\n\nArguments\n\nio::IO: the current IO stream.\nparser::Lerche.Lark: the Lerche.Lark parser to print/display.\n\nMethod List / Definition Locations\n\nshow(io, parser)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/common.jl:23.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#Base.show-Tuple{IO, OAR.CFG}","page":"Dev Index","title":"Base.show","text":"show(io::IO, cfg::OAR.CFG)\n\n\nSummary\n\nOverload of the show function for OAR.CFG.\n\nArguments\n\nio::IO: the current IO stream.\ncfg::CFG: the OAR.CFG OAR.Grammar to print/display.\n\nMethod List / Definition Locations\n\nshow(io, cfg)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:207.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#Base.show-Tuple{IO, OAR.DataSplit}","page":"Dev Index","title":"Base.show","text":"show(io::IO, data::OAR.DataSplit)\n\n\nSummary\n\nOverload of the show function for OAR.DataSplit.\n\nArguments\n\nio::IO: the current IO stream.\ndata::DataSplit: the OAR.DataSplit to print/display.\n\nMethod List / Definition Locations\n\nshow(io, data)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:133.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#Base.show-Tuple{IO, OAR.VectoredDataSplit}","page":"Dev Index","title":"Base.show","text":"show(io::IO, data::OAR.VectoredDataSplit)\n\n\nSummary\n\nOverload of the show function for OAR.VectoredDataSplit.\n\nArguments\n\nio::IO: the current IO stream.\ndata::VectoredDataSplit: the OAR.VectoredDataSplit to print/display.\n\nMethod List / Definition Locations\n\nshow(io, data)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:151.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#Base.show-Tuple{IO, ProtoNode}","page":"Dev Index","title":"Base.show","text":"show(io::IO, node::ProtoNode)\n\n\nSummary\n\nOverload of the show function for OAR.ProtoNode.\n\nArguments\n\nio::IO: the current IO stream.\nnode::ProtoNode: the OAR.ProtoNode to print/display.\n\nMethod List / Definition Locations\n\nshow(io, node)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/types.jl:469.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#Base.show-Tuple{IO, TreeNode}","page":"Dev Index","title":"Base.show","text":"show(io::IO, node::TreeNode)\n\n\nSummary\n\nOverload of the show function for OAR.TreeNode.\n\nArguments\n\nio::IO: the current IO stream.\nnode::TreeNode: the OAR.TreeNode to print/display.\n\nMethod List / Definition Locations\n\nshow(io, node)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/types.jl:510.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.CFG_from_df","page":"Dev Index","title":"OAR.CFG_from_df","text":"CFG_from_df(\n    df::DataFrames.DataFrame\n) -> Tuple{OAR.CFG{String}, Vector{Vector{GSymbol{String}}}, Any}\nCFG_from_df(\n    df::DataFrames.DataFrame,\n    label::Symbol\n) -> Tuple{OAR.CFG{String}, Vector{Vector{GSymbol{String}}}, Any}\nCFG_from_df(\n    df::DataFrames.DataFrame,\n    label::Symbol,\n    ignores::Vector{Symbol};\n    stringify\n) -> Tuple{OAR.CFG{String}, Vector{Vector{GSymbol{String}}}, Any}\n\n\nSummary\n\nConstructs a context-free grammar from a dataframe.\n\nArguments\n\ndf::DataFrame: the dataframe to turn into a OAR.CFG grammar, statements, and their labels.\nlabel::Symbol=:class: the symbolic name of the column of the DataFrame belonging to the target labels.\n\nMethod List / Definition Locations\n\nCFG_from_df(df)\nCFG_from_df(df, label)\nCFG_from_df(df, label, ignores; stringify)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:468.\n\n\n\n\n\n","category":"function"},{"location":"man/dev-index/#OAR.CMTCFG-Tuple{Vector{TreeNode}}","page":"Dev Index","title":"OAR.CMTCFG","text":"CMTCFG(statements::Vector{TreeNode}) -> OAR.CFG{String}\n\n\nSummary\n\nTurns a vector of statements in the form of OAR.TreeNodes into a CMT disease CFG grammar.\n\nArguments\n\nstatements::TreeStatements: the statements to infer the grammar from.\n\nMethod List / Definition Locations\n\nCMTCFG(statements)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:420.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.DescretizedCFG-Tuple{Vector{String}}","page":"Dev Index","title":"OAR.DescretizedCFG","text":"DescretizedCFG(N::Vector{String}; bins) -> OAR.CFG{String}\n\n\nSummary\n\nWrapper for creating a DescretizedCFG from just a vector of nonterminal symbol names as strings.\n\nThis function turns the vector of strings in to a statement and passes it to the actual constructor.\n\nArguments\n\nN::Vector{String}: the nonterminal symbol names as a vector of strings.\nbins::Integer=10: optional, the granularity/number of bins.\n\nMethod List / Definition Locations\n\nDescretizedCFG(N; bins)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:224.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.DescretizedCFG-Union{Tuple{Array{GSymbol{T}, 1}}, Tuple{T}} where T","page":"Dev Index","title":"OAR.DescretizedCFG","text":"DescretizedCFG(S::Array{GSymbol{T}, 1}; bins) -> OAR.CFG\n\n\nSummary\n\nCreates a grammer for discretizing a set of symbols into a number of bins.\n\nArguments\n\nN::Statement{T} where T <: Any: the set of non-terminal grammar symbols to use for binning.\nbins::Integer=10: optional, the granularity/number of bins.\n\nMethod List / Definition Locations\n\nDescretizedCFG(N; bins)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:224.\n\nDescretizedCFG(S; bins)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:235.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.NonTerminal-Tuple{T} where T","page":"Dev Index","title":"OAR.NonTerminal","text":"NonTerminal(data) -> GSymbol\n\n\nSummary\n\nConvenience consructor for a nonterminal grammar symbol.\n\nArguments\n\ndata::T where T <: Any: the piece of data comprising the grammar symbol of any type.\n\nMethod List / Definition Locations\n\nNonTerminal(data)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/symbols.jl:68.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.SPOCFG-Union{Tuple{Array{Array{GSymbol{T}, 1}, 1}}, Tuple{T}} where T","page":"Dev Index","title":"OAR.SPOCFG","text":"SPOCFG(\n    statements::Array{Array{GSymbol{T}, 1}, 1}\n) -> OAR.CFG{String}\n\n\nSummary\n\nConstructs a context-free grammar that uses only simple subject-predicate-object statements.\n\nArguments\n\nstatements::Statements{T} where T <: Any: the statements generated by the grammar, used to generate production rules, etc.\n\nMethod List / Definition Locations\n\nSPOCFG(statements)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:160.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.Terminal-Tuple{T} where T","page":"Dev Index","title":"OAR.Terminal","text":"Terminal(data) -> GSymbol\n\n\nSummary\n\nConvenience constructor for a terminal grammar symbol.\n\nArguments\n\ndata::T where T <: Any: the piece of data comprising the grammar symbol of any type.\n\nMethod List / Definition Locations\n\nTerminal(data)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/symbols.jl:56.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR._save_plot-Tuple{Plots.Plot, AbstractString}","page":"Dev Index","title":"OAR._save_plot","text":"_save_plot(p::Plots.Plot, filename::AbstractString) -> Any\n\n\nSummary\n\nWrapper for how figures are saved in the OAR project.\n\nArguments\n\np::Plots.Plot: the Plot object to save.\nfilename::AbstractString: the full file path as a string.\n\nMethod List / Definition Locations\n\n_save_plot(p, filename)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/plot.jl:15.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR._save_table-Tuple{Any, AbstractString}","page":"Dev Index","title":"OAR._save_table","text":"_save_table(table, filename::AbstractString) -> Any\n\n\nSummary\n\nWrapper for how tables are saved in the OAR project.\n\nArguments\n\ntable: the table object to save.\nfilename::AbstractString: the full file path as a string.\n\nMethod List / Definition Locations\n\n_save_table(table, filename)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/plot.jl:26.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR._show_datasplit-Tuple{IO, OAR.TTDataset, Int64}","page":"Dev Index","title":"OAR._show_datasplit","text":"_show_datasplit(io::IO, data::OAR.TTDataset, dim::Int64)\n\n\nSummary\n\nInternal function for handling how to show OAR.TTDatasets.\n\nMethod List / Definition Locations\n\n_show_datasplit(io, data, dim)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:110.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.accommodate_vector!-Union{Tuple{T}, Tuple{Vector{T}, Integer}} where T","page":"Dev Index","title":"OAR.accommodate_vector!","text":"accommodate_vector!(vec::Array{T, 1}, goal_len::Integer)\n\n\nSummary\n\nExtends a vector to a goal length with zeros of its element type to accommodate in-place updates.\n\nArguments\n\nvec::Vector{T}: a vector of arbitrary element type.\ngoal_len::Integer: the length that the vector should be.\n\nMethod List / Definition Locations\n\naccommodate_vector!(vec, goal_len)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:276.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.activation-Tuple{ProtoNode, Array{GSymbol{T}, 1} where T}","page":"Dev Index","title":"OAR.activation","text":"activation(\n    node::ProtoNode,\n    statement::Array{GSymbol{T}, 1} where T\n) -> Float64\n\n\nSummary\n\nComputes the ART activation of a statement on an OAR.ProtoNode.\n\nArguments\n\nnode::ProtoNode: the OAR.ProtoNode node to compute the activation for.\nstatement::Statement: the OAR.Statement used for computing the activation.\n\nMethod List / Definition Locations\n\nactivation(node, statement)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:209.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.activation-Tuple{ProtoNode, TreeNode}","page":"Dev Index","title":"OAR.activation","text":"activation(node::ProtoNode, statement::TreeNode) -> Float64\n\n\nSummary\n\nComputes the ART activation of a statement on an OAR.ProtoNode.\n\nArguments\n\nnode::ProtoNode: the OAR.ProtoNode node to compute the activation for.\nstatement::TreeNode: the OAR.TreeNode used for computing the activation.\n\nMethod List / Definition Locations\n\nactivation(node, statement)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/tn_functions.jl:54.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.add_node!-Tuple{GramART}","page":"Dev Index","title":"OAR.add_node!","text":"add_node!(art::GramART; new_cluster)\n\n\nSummary\n\nAdds an empty node to the end of the OAR.GramART module.\n\nArguments\n\nart::GramART: the OAR.GramART module to append a node to.\n\nMethod List / Definition Locations\n\nadd_node!(art; new_cluster)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:61.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.add_subtree_terminals-Tuple{Set{GSymbol{String}}, TreeNode}","page":"Dev Index","title":"OAR.add_subtree_terminals","text":"add_subtree_terminals(\n    terminals::Set{GSymbol{String}},\n    statement::TreeNode\n)\n\n\nSummary\n\nRecursive function for adding terminal symbols to a set.\n\nArguments\n\nterminals::Set{GramARTSymbol}: the set for adding/tracking all terminals.\nstatement::TreeStatment: the current statement being processed.\n\nMethod List / Definition Locations\n\nadd_subtree_terminals(terminals, statement)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:330.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.average-Tuple{AbstractVector{T} where T<:Real}","page":"Dev Index","title":"OAR.average","text":"average(field::AbstractVector{T} where T<:Real) -> Any\n\n\nSummary\n\nAverage linkage DDVFA similarity function.\n\nArguments\n\nfield::RealVector: the DDVSTART GramART F2 node field (F2.T or F2.M) to compute the linkage for.\n\nMethod List / Definition Locations\n\naverage(field)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/dv.jl:206.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.check_if_piped-Tuple{DataFrames.DataFrame, AbstractString}","page":"Dev Index","title":"OAR.check_if_piped","text":"check_if_piped(\n    data_dict::DataFrames.DataFrame,\n    name::AbstractString\n) -> Any\n\n\nSummary\n\nChecks the data dictionary if the named variable is piped.\n\nArguments\n\ndata_dict::DataFrame: the data_dictionary containing attributes about variables, such as if they are piped or not.\nname::AbtractString: the variable name to identify if it is piped.\n\nMethod List / Definition Locations\n\ncheck_if_piped(data_dict, name)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:284.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.classify-Tuple{GramART, Union{TreeNode, Array{GSymbol{T}, 1} where T}}","page":"Dev Index","title":"OAR.classify","text":"classify(\n    art::GramART,\n    statement::Union{TreeNode, Array{GSymbol{T}, 1} where T};\n    get_bmu\n) -> Any\n\n\nSummary\n\nClassifies the OAR.Statement into one of OAR.GramART's internal categories.\n\nArguments\n\nart::GramART: the OAR.GramART to use in classification/inference.\nstatement::SomeStatement: the OAR.SomeStatement to classify.\nget_bmu::Bool=false: optional, whether to get the best matching unit in the case of complete mismatch.\n\nMethod List / Definition Locations\n\nclassify(art, statement; get_bmu)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:371.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.classify_dv-Tuple{GramART, Array{GSymbol{T}, 1} where T}","page":"Dev Index","title":"OAR.classify_dv","text":"classify_dv(\n    art::GramART,\n    statement::Array{GSymbol{T}, 1} where T;\n    get_bmu\n) -> Any\n\n\nSummary\n\nClassifies the OAR.Statement into one of OAR.GramART's internal categories.\n\nArguments\n\nart::GramART: the OAR.GramART to use in classification/inference.\nstatement::Statement: the OAR.Statement to classify.\nget_bmu::Bool=false: optional, whether to get the best matching unit in the case of complete mismatch.\n\nMethod List / Definition Locations\n\nclassify_dv(art, statement; get_bmu)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/dv.jl:129.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.cluster_stats_plot-Tuple{DataFrames.DataFrame}","page":"Dev Index","title":"OAR.cluster_stats_plot","text":"cluster_stats_plot(\n    df::DataFrames.DataFrame;\n    avg,\n    err,\n    n,\n    fontsize,\n    kwargs...\n) -> Plots.Plot\n\n\nSummary\n\nGenerates the plot for the cluster statistics.\n\nArguments\n\ndf::DataFrame: the dataframe with the clusters vs. rho to plot.\navg::Bool=false: flag for using the sliding average procedure.\nerr::Bool=false: flag for using a StatsPlots errorline!.\nn::Integer=10: used if avg is high, the size of the sliding window.\n\nMethod List / Definition Locations\n\ncluster_stats_plot(df; avg, err, n, fontsize, kwargs...)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/plot.jl:111.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.complete-Tuple{AbstractVector{T} where T<:Real}","page":"Dev Index","title":"OAR.complete","text":"complete(field::AbstractVector{T} where T<:Real) -> Any\n\n\nSummary\n\nComplete linkage DDVFA similarity function.\n\nArguments\n\nfield::RealVector: the DDVSTART GramART F2 node field (F2.T or F2.M) to compute the linkage for.\n\nMethod List / Definition Locations\n\ncomplete(field)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/dv.jl:215.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.config_dir-Tuple","page":"Dev Index","title":"OAR.config_dir","text":"config_dir(args...) -> String\n\n\nSummary\n\nPoints to the configs directory.\n\nArguments\n\nargs...: the string directories to append to the directory.\n\nMethod List / Definition Locations\n\nconfig_dir(args)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/drwatson.jl:53.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.create_category!-Tuple{GramART, Union{TreeNode, Array{GSymbol{T}, 1} where T}, Integer}","page":"Dev Index","title":"OAR.create_category!","text":"create_category!(\n    art::GramART,\n    statement::Union{TreeNode, Array{GSymbol{T}, 1} where T},\n    label::Integer;\n    new_cluster\n)\n\n\nSummary\n\nAdds a recursively-generated OAR.ProtoNode to the OAR.GramART module.\n\nArguments\n\nart::GramART: the OAR.GramART to append a new node to.\n\nMethod List / Definition Locations\n\ncreate_category!(art, statement, label; new_cluster)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:104.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.data_dir-Tuple","page":"Dev Index","title":"OAR.data_dir","text":"data_dir(args...) -> String\n\n\nSummary\n\nPoints to the data directory.\n\nArguments\n\nargs...: the string directories to append to the directory.\n\nMethod List / Definition Locations\n\ndata_dir(args)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/drwatson.jl:42.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.df_to_statements","page":"Dev Index","title":"OAR.df_to_statements","text":"df_to_statements(\n    df::DataFrames.DataFrame\n) -> Tuple{Vector{GSymbol{String}}, Vector{Vector{GSymbol{String}}}, Any}\ndf_to_statements(\n    df::DataFrames.DataFrame,\n    label::Symbol\n) -> Tuple{Vector{GSymbol{String}}, Vector{Vector{GSymbol{String}}}, Any}\ndf_to_statements(\n    df::DataFrames.DataFrame,\n    label::Symbol,\n    ignores::Vector{Symbol};\n    stringify\n) -> Tuple{Vector{GSymbol{String}}, Vector{Vector{GSymbol{String}}}, Any}\n\n\nSummary\n\nConvert a dataframe into a ordered vector of nonterminals, simple statements in those positions, and their labels.\n\nArguments\n\ndf::DataFrame: the dataframe containing rows corresponding to simple statements.\nlabel::Symbol=:class: the symbolic name of the column corresponding to the target labels.\n\nMethod List / Definition Locations\n\ndf_to_statements(df)\ndf_to_statements(df, label)\ndf_to_statements(df, label, ignores; stringify)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:413.\n\n\n\n\n\n","category":"function"},{"location":"man/dev-index/#OAR.df_to_trees-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Dev Index","title":"OAR.df_to_trees","text":"df_to_trees(\n    data::DataFrames.DataFrame,\n    data_dict::DataFrames.DataFrame\n) -> Vector{TreeNode}\n\n\nSummary\n\nTurns a protein data DataFrame into a vector of OAR.TreeNodes.\n\nArguments\n\ndata::DataFrame: the DataFrame containing rows of elements to turn into statements via OAR.TreeNodes.\ndata_dict::DataFrame: the DataFrame containing attributes about the columns of the protein data, such as if they are piped or not.\n\nMethod List / Definition Locations\n\ndf_to_trees(data, data_dict)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:296.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.dist_exp_parse","page":"Dev Index","title":"OAR.dist_exp_parse","text":"dist_exp_parse() -> Any\ndist_exp_parse(description::AbstractString) -> Any\n\n\nSummary\n\nParses the command line for common options in distributed experiments.\n\nArguments\n\ndescription::AbstractString: optional positional, the script description for the parser\n\nMethod List / Definition Locations\n\ndist_exp_parse()\ndist_exp_parse(description)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/file.jl:86.\n\n\n\n\n\n","category":"function"},{"location":"man/dev-index/#OAR.exp_parse","page":"Dev Index","title":"OAR.exp_parse","text":"exp_parse() -> Any\nexp_parse(description::AbstractString) -> Any\n\n\nSummary\n\nParses the command line for common options in serial (non-distributed) experiments.\n\nArguments\n\ndescription::AbstractString: optional positional, the script description for the parser\n\nMethod List / Definition Locations\n\nexp_parse()\nexp_parse(description)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/file.jl:60.\n\n\n\n\n\n","category":"function"},{"location":"man/dev-index/#OAR.get_argparsesettings","page":"Dev Index","title":"OAR.get_argparsesettings","text":"get_argparsesettings() -> Any\nget_argparsesettings(description::AbstractString) -> Any\n\n\nSummary\n\nCommon function for how ArgParse.ArgParseSettings are generated in the project.\n\nArguments\n\ndescription::AbstractString: optional positional, the script description for the parser\n\nMethod List / Definition Locations\n\nget_argparsesettings()\nget_argparsesettings(description)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/file.jl:43.\n\n\n\n\n\n","category":"function"},{"location":"man/dev-index/#OAR.get_cmt_parser-Tuple{}","page":"Dev Index","title":"OAR.get_cmt_parser","text":"get_cmt_parser() -> Lerche.Lark\n\n\nSummary\n\nConstructs and returns a parser for the KG edge attributes data.\n\nMethod List / Definition Locations\n\nget_cmt_parser()\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:96.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.get_gramart_instance_counts-Tuple{GramART}","page":"Dev Index","title":"OAR.get_gramart_instance_counts","text":"get_gramart_instance_counts(art::GramART) -> Vector{Int64}\n\n\nSummary\n\nGramART utility: returns a list of the instance counts for each OAR.GramART prototype.\n\nArguments\n\nart::GramART: the OAR.GramART module to analyze.\n\nMethod List / Definition Locations\n\nget_gramart_instance_counts(art)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:448.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.get_iris_parser-Tuple{}","page":"Dev Index","title":"OAR.get_iris_parser","text":"get_iris_parser() -> Lerche.Lark\n\n\nSummary\n\nConstructs and returns a Lerche parser for the symbolic IRIS dataset.\n\nMethod List / Definition Locations\n\nget_iris_parser()\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/iris.jl:25.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.get_kg_parser-Tuple{}","page":"Dev Index","title":"OAR.get_kg_parser","text":"get_kg_parser() -> Lerche.Lark\n\n\nSummary\n\nConstructs and returns a parser for the KG edge attributes data.\n\nMethod List / Definition Locations\n\nget_kg_parser()\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/kg.jl:34.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.get_kg_statements-Tuple{AbstractString}","page":"Dev Index","title":"OAR.get_kg_statements","text":"get_kg_statements(\n    file::AbstractString\n) -> Vector{Vector{GSymbol{String}}}\n\n\nSummary\n\nLoads the KG edge data file, parses the lines, and returns a vector of statements for GramART.\n\nArguments\n\nfile::AbstractString: the location of the edge data file.\n\nMethod List / Definition Locations\n\nget_kg_statements(file)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/kg.jl:69.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.get_mldata","page":"Dev Index","title":"OAR.get_mldata","text":"get_mldata(mldataset::Symbol) -> Any\nget_mldata(mldataset::Symbol, download_local::Bool) -> Any\n\n\nSummary\n\nWrapper for downloading and/or loading a dataset from MLDatasets.\n\nArguments\n\nmldataest::Symbol: the symbolic name of the MLDataset to download/load.\ndownload_local::Bool=false: default false, flag to download the dataset to the local cache directory.\n\nMethod List / Definition Locations\n\nget_mldata(mldataset)\nget_mldata(mldataset, download_local)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:189.\n\n\n\n\n\n","category":"function"},{"location":"man/dev-index/#OAR.get_piped_parser-Tuple{}","page":"Dev Index","title":"OAR.get_piped_parser","text":"get_piped_parser() -> Lerche.Lark\n\n\nSummary\n\nConstructs and returns a parser for just piped strings.\n\nMethod List / Definition Locations\n\nget_piped_parser()\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:228.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.get_positive_dist-Tuple{GramART, AbstractString, Integer}","page":"Dev Index","title":"OAR.get_positive_dist","text":"get_positive_dist(\n    art::GramART,\n    nonterminal::AbstractString,\n    index::Integer\n) -> Dict{GSymbol{String}, Float64}\n\n\nSummary\n\nGramART utility: gets the positive distribution.\n\nArguments\n\nart::GramART: the OAR.GramART module to analyze.\nnonterminal::AbstractString: the string name of the nonterminal position to analyze.\nindex::Integer: the index of the OAR.ProtoNode to analyze.\n\nMethod List / Definition Locations\n\nget_positive_dist(art, nonterminal, index)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:427.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.get_production_rules-Union{Tuple{T}, Tuple{Array{GSymbol{T}, 1}, Array{Array{GSymbol{T}, 1}, 1}}} where T","page":"Dev Index","title":"OAR.get_production_rules","text":"get_production_rules(\n    N::Array{GSymbol{T}, 1},\n    statements::Array{Array{GSymbol{T}, 1}, 1}\n) -> Dict{GSymbol{_A}, Set{GSymbol{_A}}} where _A\n\n\nSummary\n\nGenerates simple production rules from a vector of statements and the nonterminals corresponding to them.\n\nArguments\n\nN:Statement{T} where T <: Any: the ordered nonterminals corresponding to the columns of the statement.\nstatements::Statements{T} where: the list of statements used for generating the production rules.\n\nMethod List / Definition Locations\n\nget_production_rules(N, statements)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:132.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.get_terminals-Union{Tuple{Array{Array{GSymbol{T}, 1}, 1}}, Tuple{T}} where T","page":"Dev Index","title":"OAR.get_terminals","text":"get_terminals(\n    statements::Array{Array{GSymbol{T}, 1}, 1}\n) -> Set\n\n\nSummary\n\nGenerates a set of unique terminal symbols from a list of statements.\n\nArguments\n\nstatements::Statements{T} where T <: Any: the statements to dissect into a set of terminals.\n\nMethod List / Definition Locations\n\nget_terminals(statements)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:113.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.get_tree_production_rules-Tuple{Vector{GSymbol{String}}, Vector{TreeNode}}","page":"Dev Index","title":"OAR.get_tree_production_rules","text":"get_tree_production_rules(\n    N::Vector{GSymbol{String}},\n    statements::Vector{TreeNode}\n) -> Dict{GSymbol{String}, Set{GSymbol{String}}}\n\n\nSummary\n\nTakes a set of nonterminals and a set of statements and returns their corresponding production rules.\n\nArguments\n\nN::Vector{GramARTSymbol}: the nonterminal symbols of the grammar.\nstatements::TreeStatements: the statements to infer production rules from.\n\nMethod List / Definition Locations\n\nget_tree_production_rules(N, statements)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:383.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.get_tree_terminals-Tuple{Vector{TreeNode}}","page":"Dev Index","title":"OAR.get_tree_terminals","text":"get_tree_terminals(\n    statements::Vector{TreeNode}\n) -> Set{GSymbol{String}}\n\n\nSummary\n\nGets all of the terminal symbols contained in a set of OAR.TreeStatements.\n\nArguments\n\nstatements::TreeStatments: the statements containing terminal symbols.\n\nMethod List / Definition Locations\n\nget_tree_terminals(statements)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:352.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.get_windows-Tuple{AbstractVector{T} where T<:Real, Integer}","page":"Dev Index","title":"OAR.get_windows","text":"get_windows(\n    vs::AbstractVector{T} where T<:Real,\n    n::Integer\n) -> Any\n\n\nSummary\n\nConstructs a windowed matrix of a vector.\n\nArguments\n\nvs::RealVector: the original vector.\nn::Integer: the size of the sliding window.\n\nMethod List / Definition Locations\n\nget_windows(vs, n)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/plot.jl:86.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.inc_update_symbols!-Tuple{ProtoNode, GSymbol{String}, GSymbol{String}, Bool}","page":"Dev Index","title":"OAR.inc_update_symbols!","text":"inc_update_symbols!(\n    pn::ProtoNode,\n    nonterminal::GSymbol{String},\n    symb::GSymbol{String},\n    terminated::Bool\n)\n\n\nSummary\n\nUpdates the tree of OAR.ProtoNode from a single terminal.\n\nArguments\n\npn::ProtoNode: the top of the OAR.ProtoNode tree to update.\nnonterminal::GramARTSymbol: the nonterminal symbol of the statement to update at.\nsymb::GramARTSymbol: the terminal symbol to update everywhere.\n\nMethod List / Definition Locations\n\ninc_update_symbols!(pn, nonterminal, symb, terminated)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:155.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.integer_encoding-Tuple{Any}","page":"Dev Index","title":"OAR.integer_encoding","text":"integer_encoding(vec) -> Any\n\n\nSummary\n\nInternal implementation of integer encoding.\n\nArguments\n\nvec: some iterable collection containing unique elements to turn into a vector of integers.\n\nMethod List / Definition Locations\n\ninteger_encoding(vec)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:450.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.is_nonterminal-Union{Tuple{T}, Tuple{OAR.Grammar{T}, GSymbol{T}}} where T","page":"Dev Index","title":"OAR.is_nonterminal","text":"is_nonterminal(\n    grammar::OAR.Grammar{T},\n    symb::GSymbol{T}\n) -> Any\n\n\nSummary\n\nChecks if a symbol is non-terminal in the grammar.\n\nArguments\n\ngrammar::Grammar{T} where T <: Any: a subtype of the abstract OAR.Grammar{T} type.\nsymb::GSymbol: the grammar symbol to use.\n\nMethod List / Definition Locations\n\nis_nonterminal(grammar, symb)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:316.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.is_terminal-Tuple{GSymbol}","page":"Dev Index","title":"OAR.is_terminal","text":"is_terminal(symb::GSymbol) -> Bool\n\n\nSummary\n\nChecks if the OAR.GSymbol is a terminal grammar symbol.\n\nArguments\n\nsymb::GSymbol: the OAR.GSymbol to check.\n\nMethod List / Definition Locations\n\nis_terminal(symb)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:26.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.is_terminal-Tuple{TreeNode}","page":"Dev Index","title":"OAR.is_terminal","text":"is_terminal(treenode::TreeNode) -> Bool\n\n\nSummary\n\nChecks if the OAR.TreeNode contains a terminal symbol.\n\nArguments\n\ntreenode::TreeNode: the OAR.TreeNode to containing the OAR.GSymbol to check if terminal.\n\nMethod List / Definition Locations\n\nis_terminal(treenode)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:37.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.is_terminal-Union{Tuple{T}, Tuple{OAR.Grammar{T}, GSymbol{T}}} where T","page":"Dev Index","title":"OAR.is_terminal","text":"is_terminal(\n    grammar::OAR.Grammar{T},\n    symb::GSymbol{T}\n) -> Any\n\n\nSummary\n\nChecks if a symbol is terminal in the grammar.\n\nArguments\n\ngrammar::Grammar{T} where T <: Any: a subtype of the abstract OAR.Grammar{T} type.\nsymb::GSymbol: the grammar symbol to use.\n\nMethod List / Definition Locations\n\nis_terminal(symb)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:26.\n\nis_terminal(treenode)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:37.\n\nis_terminal(grammar, symb)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:306.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.join_gsymbol-Union{Tuple{T}, Tuple{GSymbol{T}, Integer}} where T<:AbstractString","page":"Dev Index","title":"OAR.join_gsymbol","text":"join_gsymbol(\n    symb::GSymbol{T<:AbstractString},\n    num::Integer;\n    terminal\n) -> GSymbol{String}\n\n\nSummary\n\nReturns a new OAR.GSymbol by adding a suffix.\n\nArguments\n\nsymb::GSymbol{T} where T <: AbstractString: the original symbol to append a suffix to.\nnum::Integer: the integer to add as a suffix to the symbol.\nterminal::Bool=true: optional (default true), to set the new symbol as terminal.\n\nMethod List / Definition Locations\n\njoin_gsymbol(symb, num; terminal)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/symbols.jl:87.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.learn!-Tuple{GramART, Array{GSymbol{T}, 1} where T, Integer}","page":"Dev Index","title":"OAR.learn!","text":"learn!(\n    art::GramART,\n    statement::Array{GSymbol{T}, 1} where T,\n    index::Integer\n)\n\n\nSummary\n\nProcesses a statement for a OAR.GramART module.\n\nArguments\n\nart::GramART: the OAR.GramART to update with the statement.\nstatement::Statement: the grammar OAR.Statement to process.\nindex::Integer: the index of the OAR.ProtoNode to update.\n\nMethod List / Definition Locations\n\nlearn!(art, statement, index)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:186.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.learn!-Tuple{GramART, TreeNode, Integer}","page":"Dev Index","title":"OAR.learn!","text":"learn!(\n    gramart::GramART,\n    statement::TreeNode,\n    index::Integer\n)\n\n\nSummary\n\nProcesses a statement for a OAR.GramART module.\n\nArguments\n\ngramart::GramART: the OAR.GramART to update with the statement.\nstatement::TreeNode: the grammar OAR.TreeNode to process.\nindex::Integer: the index of the OAR.ProtoNode to update.\n\nMethod List / Definition Locations\n\nlearn!(gramart, statement, index)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/tn_functions.jl:16.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.load_cmt-Tuple{AbstractString}","page":"Dev Index","title":"OAR.load_cmt","text":"load_cmt(file::AbstractString) -> DataFrames.DataFrame\n\n\nSummary\n\nLoads and sanitizes the CMT protein dataframe.\n\nArguments\n\nfile::AbstractString: the location of the CSV file containing CMT protein data.\n\nMethod List / Definition Locations\n\nload_cmt(file)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:152.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.load_cmt_dict-Tuple{AbstractString}","page":"Dev Index","title":"OAR.load_cmt_dict","text":"load_cmt_dict(file::AbstractString) -> DataFrames.DataFrame\n\n\nSummary\n\nLoads and sanitizes the CMT data dictionary file.\n\nArguments\n\nfile::AbstractString: the location of the data dictionary CSV file.\n\nMethod List / Definition Locations\n\nload_cmt_dict(file)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:184.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.load_config-Tuple{AbstractString}","page":"Dev Index","title":"OAR.load_config","text":"load_config(config_file::AbstractString) -> Any\n\n\nSummary\n\nLoads the provided configuration YAML file.\n\nArguments\n\nconfig_file::AbstractString: the config file name as a string.\n\nMethod List / Definition Locations\n\nload_config(config_file)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/file.jl:26.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.match-Tuple{ProtoNode, Array{GSymbol{T}, 1} where T}","page":"Dev Index","title":"OAR.match","text":"match(\n    node::ProtoNode,\n    statement::Array{GSymbol{T}, 1} where T\n) -> Float64\n\n\nSummary\n\nComputes the ART match of a statement on an OAR.ProtoNode.\n\nArguments\n\nnode::ProtoNode: the OAR.ProtoNode node to compute the match for.\nstatement::Statement: the OAR.Statement used for computing the match.\n\nMethod List / Definition Locations\n\nmatch(node, statement)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:234.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.match-Tuple{ProtoNode, TreeNode}","page":"Dev Index","title":"OAR.match","text":"match(node::ProtoNode, statement::TreeNode) -> Float64\n\n\nSummary\n\nComputes the ART match of a statement on an OAR.ProtoNode.\n\nArguments\n\nnode::ProtoNode: the OAR.ProtoNode node to compute the match for.\nstatement::TreeNode: the OAR.TreeNode used for computing the match.\n\nMethod List / Definition Locations\n\nmatch(node, statement)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/tn_functions.jl:85.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.median-Tuple{AbstractVector{T} where T<:Real}","page":"Dev Index","title":"OAR.median","text":"median(field::AbstractVector{T} where T<:Real) -> Any\n\n\nSummary\n\nMedian linkage DDVFA similarity function.\n\nArguments\n\nfield::RealVector: the DDVSTART GramART F2 node field (F2.T or F2.M) to compute the linkage for.\n\nMethod List / Definition Locations\n\nmedian(field)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/dv.jl:224.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.paper_results_dir-Tuple","page":"Dev Index","title":"OAR.paper_results_dir","text":"paper_results_dir(args...) -> String\n\n\nSummary\n\nDrWatson-style paper results directory.\n\nArguments\n\nargs...: the string directories to append to the directory.\n\nMethod List / Definition Locations\n\npaper_results_dir(args)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/drwatson.jl:64.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.parse_grammar-Union{Tuple{T}, Tuple{OAR.Grammar{T}, Array{GSymbol{T}, 1}}} where T","page":"Dev Index","title":"OAR.parse_grammar","text":"parse_grammar(\n    grammar::OAR.Grammar{T},\n    statement::Array{GSymbol{T}, 1}\n)\n\n\nSummary\n\nParses and checks that a statement is permissible under a grammer.\n\nArguments\n\ngrammar::Grammar{T} where T <: Any: a subtype of the abstract OAR.Grammar{T} type.\nstatement::Statement{T} where T <: Any: a grammar [OAR.Statement] to check the validity of.s\n\nMethod List / Definition Locations\n\nparse_grammar(grammar, statement)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:286.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.print_treenode_children-Tuple{IO, TreeNode, Integer, Bool}","page":"Dev Index","title":"OAR.print_treenode_children","text":"print_treenode_children(\n    io::IO,\n    node::TreeNode,\n    level::Integer,\n    last::Bool\n)\n\n\nSummary\n\nPrints a tree string for displaying children of a OAR.TreeNode, used in the Base.show overload.\n\nArguments\n\nio::IO: the current IO stream.\nnode::TreeNode: the OAR.TreeNode with children to display\n\nMethod List / Definition Locations\n\nprint_treenode_children(io, node, level, last)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/types.jl:480.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.protein_df_to_strings-Tuple{DataFrames.DataFrame}","page":"Dev Index","title":"OAR.protein_df_to_strings","text":"protein_df_to_strings(\n    df::DataFrames.DataFrame\n) -> Vector{String}\n\n\nSummary\n\nTurns the CMT protein DataFrame into a vector of string statements.\n\nArguments\n\ndf::DataFrame: the sanitized CMT protein data DataFrame.\n\nMethod List / Definition Locations\n\nprotein_df_to_strings(df)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:199.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.quick_statement-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"Dev Index","title":"OAR.quick_statement","text":"quick_statement(data::Array{T, 1}; terminal) -> Any\n\n\nSummary\n\nCreates a OAR.Statement from a vector of elements of arbitrary type.\n\nArguments\n\ndata::Vector{T} where T <: Any: a vector of any type for creating a OAR.Statement of symbols of that type.\nterminal::Bool=false: optional, if the symbols of the statement are terminal.\n\nMethod List / Definition Locations\n\nquick_statement(data; terminal)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:194.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.random_produce-Union{Tuple{T}, Tuple{OAR.Grammar{T}, GSymbol{T}}} where T","page":"Dev Index","title":"OAR.random_produce","text":"random_produce(\n    grammar::OAR.Grammar{T},\n    symb::GSymbol{T}\n) -> Any\n\n\nSummary\n\nProduces a random terminal from the non-terminal using the corresponding production rule.\n\nArguments\n\ngrammar::Grammar{T} where T <: Any: a subtype of the abstract OAR.Grammar{T} type.\nsymb::GSymbol: the grammar symbol to use.\n\nMethod List / Definition Locations\n\nrandom_produce(grammar, symb)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:296.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.random_statement-Union{Tuple{OAR.Grammar{T}}, Tuple{T}} where T","page":"Dev Index","title":"OAR.random_statement","text":"random_statement(grammar::OAR.Grammar{T}) -> Vector\n\n\nSummary\n\nGenerates a random statement from a grammar.\n\nArguments\n\ngrammar::Grammar{T} where T <: Any: a subtype of the abstract OAR.Grammar{T} type.\n\nMethod List / Definition Locations\n\nrandom_statement(grammar)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/grammar/grammar.jl:326.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.real_to_symb-Tuple{OAR.DataSplit, Vector{String}}","page":"Dev Index","title":"OAR.real_to_symb","text":"real_to_symb(\n    data::OAR.DataSplit,\n    labels::Vector{String};\n    bins\n) -> Tuple{OAR.VectoredDataSplit{GSymbol{String}, Int64}, OAR.CFG{String}}\n\n\nSummary\n\nTurns a OAR.DataSplit into a binned symbolic variant for use with GramART.\n\nArguments\n\ndata::DataSplit: the OAR.DataSplit to convert to symbols.\nlabels::Vector{String}: the labels corresponding to the non-terminal symbol names for the feature categories and their subsequent terminal variants.\nbins::Int=10: optional, the number of symbols to descretize the real-valued data to.\n\nMethod List / Definition Locations\n\nreal_to_symb(data, labels; bins)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:259.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.results_dir-Tuple","page":"Dev Index","title":"OAR.results_dir","text":"results_dir(args...) -> String\n\n\nSummary\n\nPoints to the results directory.\n\nArguments\n\nargs...: the string directories to append to the directory.\n\nMethod List / Definition Locations\n\nresults_dir(args)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/drwatson.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.run_parser-Tuple{Lerche.Lark, AbstractString}","page":"Dev Index","title":"OAR.run_parser","text":"run_parser(parser::Lerche.Lark, text::AbstractString) -> Any\n\n\nSummary\n\nWrapper for running a parser with a given piece of text in the form of a string.\n\nMethod List / Definition Locations\n\nrun_parser(parser, text)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/common.jl:11.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.save_dataframe-Tuple{DataFrames.DataFrame, AbstractString}","page":"Dev Index","title":"OAR.save_dataframe","text":"save_dataframe(\n    df::DataFrames.DataFrame,\n    savename::AbstractString\n)\n\n\nSummary\n\nWrapper for how to save DataFrames in the OAR project.\n\nArguments\n\ndf::DataFrame: the dataframe to save.\nsavename::AbstractString: the location to save the dataframe.\n\nMethod List / Definition Locations\n\nsave_dataframe(df, savename)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/file.jl:123.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.save_plot-Tuple{Plots.Plot, AbstractString, AbstractString, AbstractString}","page":"Dev Index","title":"OAR.save_plot","text":"save_plot(\n    p::Plots.Plot,\n    fig_name::AbstractString,\n    exp_top::AbstractString,\n    exp_name::AbstractString\n)\n\n\nSummary\n\nSaves the plot to the both the local results directory and to the paper directory.\n\nArguments\n\np::Plots.Plot: the handle of the plot to save.\nfig_name::AbstractString: the name of the figure file itself.\nexp_top::AbstractString: the top of the experiment directory.\nexp_name::AbstractString: the name of the experiment itself.\n\nMethod List / Definition Locations\n\nsave_plot(p, fig_name, exp_top, exp_name)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/plot.jl:49.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.save_sim-Tuple{Function, AbstractDict, AbstractDict}","page":"Dev Index","title":"OAR.save_sim","text":"save_sim(\n    dir_func::Function,\n    d::AbstractDict,\n    fulld::AbstractDict\n)\n\n\nSummary\n\nCommon save function for simulations.\n\nArguments\n\ndir_func::Function: the function that provides the correct file path with provided strings.\nd::AbstractDict: the simulation options dictionary.\nfulld::AbstractDict: the dictionary containing the sim results.\n\nMethod List / Definition Locations\n\nsave_sim(dir_func, d, fulld)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/experiments.jl:16.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.single-Tuple{AbstractVector{T} where T<:Real}","page":"Dev Index","title":"OAR.single","text":"single(field::AbstractVector{T} where T<:Real) -> Any\n\n\nSummary\n\nSingle linkage DDVFA similarity function.\n\nArguments\n\nfield::RealVector: the DDVSTART GramART F2 node field (F2.T or F2.M) to compute the linkage for.\n\nMethod List / Definition Locations\n\nsingle(field)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/dv.jl:197.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.sliding_avg-Tuple{AbstractVector{T} where T<:Real, Integer}","page":"Dev Index","title":"OAR.sliding_avg","text":"sliding_avg(\n    vs::AbstractVector{T} where T<:Real,\n    n::Integer\n) -> Any\n\n\nSummary\n\nComputes the sliding window average of a vector with window size n.\n\nArguments\n\nvs::RealVector: the original vector for sliding window averages.\nn::Integer: the size of the sliding window.\n\nMethod List / Definition Locations\n\nsliding_avg(vs, n)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/plot.jl:72.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.symbolic_cluster_dataset","page":"Dev Index","title":"OAR.symbolic_cluster_dataset","text":"symbolic_cluster_dataset(\n    filename::AbstractString\n) -> Tuple{Vector{Vector{GSymbol{String}}}, OAR.CFG{String}}\nsymbolic_cluster_dataset(\n    filename::AbstractString,\n    bins::Int64\n) -> Tuple{Vector{Vector{GSymbol{String}}}, OAR.CFG{String}}\n\n\nSummary\n\nGenerates a OAR.DataSplitGeneric and OAR.CFG grammart from the provided CSV dataset.\n\nArguments\n\nfilename::AbstractString=data_dir(\"mushroom\", \"mushrooms.csv\"): the location of the file to load with a default value.\n\nMethod List / Definition Locations\n\nsymbolic_cluster_dataset(filename)\nsymbolic_cluster_dataset(filename, bins)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:607.\n\n\n\n\n\n","category":"function"},{"location":"man/dev-index/#OAR.symbolic_dataset","page":"Dev Index","title":"OAR.symbolic_dataset","text":"symbolic_dataset(\n    filename::AbstractString\n) -> Tuple{OAR.VectoredDataSplit{GSymbol{String}, Int64}, OAR.CFG{String}}\nsymbolic_dataset(\n    filename::AbstractString,\n    bins::Int64\n) -> Tuple{OAR.VectoredDataSplit{GSymbol{String}, Int64}, OAR.CFG{String}}\n\n\nSummary\n\nGenerates a OAR.DataSplitGeneric and OAR.CFG grammart from the provided CSV dataset.\n\nArguments\n\nfilename::AbstractString=data_dir(\"mushroom\", \"mushrooms.csv\"): the location of the file to load with a default value.\n\nMethod List / Definition Locations\n\nsymbolic_dataset(filename)\nsymbolic_dataset(filename, bins)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:578.\n\n\n\n\n\n","category":"function"},{"location":"man/dev-index/#OAR.symbolic_iris-Tuple{}","page":"Dev Index","title":"OAR.symbolic_iris","text":"symbolic_iris(\n;\n    bins,\n    download_local\n) -> Tuple{OAR.VectoredDataSplit{GSymbol{String}, Int64}, OAR.CFG{String}}\n\n\nSummary\n\nQuickly generates a [OAR.VectoredDataSplit] of the symbolic Iris dataset.\n\nArguments\n\nbins::Int=10: optional, the number of symbols to descretize the real-valued data to.\ndownload_local::Bool=false: optional (default false), to download the Iris dataset to the local datadir.\n\nMethod List / Definition Locations\n\nsymbolic_iris(; bins, download_local)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:353.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.symbolic_lung_cancer","page":"Dev Index","title":"OAR.symbolic_lung_cancer","text":"symbolic_lung_cancer(\n\n) -> Tuple{OAR.DataSplitGeneric, OAR.CFG{String}}\nsymbolic_lung_cancer(\n    filename::AbstractString\n) -> Tuple{OAR.DataSplitGeneric, OAR.CFG{String}}\n\n\nSummary\n\nGenerates a OAR.DataSplitGeneric and OAR.CFG grammart from the Lung Cancer dataset.\n\nArguments\n\nfilename::AbstractString=data_dir(\"lung-cancer\", \"lung-cancer.csv\"): the location of the file to load with a default value.\n\nMethod List / Definition Locations\n\nsymbolic_lung_cancer()\nsymbolic_lung_cancer(filename)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:547.\n\n\n\n\n\n","category":"function"},{"location":"man/dev-index/#OAR.symbolic_mushroom","page":"Dev Index","title":"OAR.symbolic_mushroom","text":"symbolic_mushroom(\n\n) -> Tuple{OAR.DataSplitGeneric, OAR.CFG{String}}\nsymbolic_mushroom(\n    filename::AbstractString\n) -> Tuple{OAR.DataSplitGeneric, OAR.CFG{String}}\n\n\nSummary\n\nGenerates a OAR.DataSplitGeneric and OAR.CFG grammart from the Mushroom dataset.\n\nArguments\n\nfilename::AbstractString=data_dir(\"mushroom\", \"mushrooms.csv\"): the location of the file to load with a default value.\n\nMethod List / Definition Locations\n\nsymbolic_mushroom()\nsymbolic_mushroom(filename)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:526.\n\n\n\n\n\n","category":"function"},{"location":"man/dev-index/#OAR.symbolic_wine-Tuple{}","page":"Dev Index","title":"OAR.symbolic_wine","text":"symbolic_wine(\n;\n    bins,\n    download_local\n) -> Tuple{OAR.VectoredDataSplit{GSymbol{String}, Int64}, OAR.CFG{String}}\n\n\nSummary\n\nQuickly generates a [OAR.VectoredDataSplit] of the symbolic Wine dataset.\n\nArguments\n\nbins::Int=10: optional, the number of symbols to descretize the real-valued data to.\ndownload_local::Bool=false: optional (default false), to download the Wine dataset to the local datadir.\n\nMethod List / Definition Locations\n\nsymbolic_wine(; bins, download_local)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:377.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.tc_gramart-Tuple{AbstractDict, Union{Vector{TreeNode}, Array{Array{GSymbol{T}, 1}, 1} where T}, Function, AbstractDict}","page":"Dev Index","title":"OAR.tc_gramart","text":"tc_gramart(\n    d::AbstractDict,\n    ts::Union{Vector{TreeNode}, Array{Array{GSymbol{T}, 1}, 1} where T},\n    dir_func::Function,\n    opts::AbstractDict\n)\n\n\nSummary\n\nTrains and classifies a GramART module on the provided statements.\n\nArguments\n\nd::AbstractDict: the simulation options dictionary.\nts::SomeStatements: a set of statements of type Union{TreeStatements, Statements}.\ndir_func::Function: the function that provides the correct file path with provided strings.\nopts::AbstractDict: additional options for the simulation.\n\nMethod List / Definition Locations\n\ntc_gramart(d, ts, dir_func, opts)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/experiments.jl:51.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.train!-Tuple{GramART, Union{TreeNode, Array{GSymbol{T}, 1} where T}}","page":"Dev Index","title":"OAR.train!","text":"train!(\n    art::GramART,\n    statement::Union{TreeNode, Array{GSymbol{T}, 1} where T};\n    y\n) -> Any\n\n\nSummary\n\nTrains OAR.GramART module on a OAR.SomeStatement from the OAR.GramART's grammar.\n\nArguments\n\nart::GramART: the OAR.GramART to update with the OAR.SomeStatement.\nstatement::SomeStatement: the grammar OAR.SomeStatement to train upon.\ny::Integer=0: optional supervised label as an integer.\n\nMethod List / Definition Locations\n\ntrain!(art, statement; y)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:291.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.train_dv!-Tuple{GramART, Union{TreeNode, Array{GSymbol{T}, 1} where T}}","page":"Dev Index","title":"OAR.train_dv!","text":"train_dv!(\n    art::GramART,\n    statement::Union{TreeNode, Array{GSymbol{T}, 1} where T};\n    y\n) -> Any\n\n\nSummary\n\nTrains OAR.GramART module on a OAR.SomeStatement from the OAR.GramART's grammar.\n\nArguments\n\nart::GramART: the OAR.GramART to update with the OAR.SomeStatement.\nstatement::SomeStatement: the grammar OAR.SomeStatement to process.\ny::Integer=0: optional supervised label as an integer.\n\nMethod List / Definition Locations\n\ntrain_dv!(art, statement; y)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/dv.jl:44.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.tt_gramart-Tuple{AbstractDict, OAR.VectoredDataset, Function, AbstractDict}","page":"Dev Index","title":"OAR.tt_gramart","text":"tt_gramart(\n    d::AbstractDict,\n    data::OAR.VectoredDataset,\n    dir_func::Function,\n    opts::AbstractDict\n)\n\n\nSummary\n\nTrains and tests a GramART module on the provided statements.\n\nArguments\n\nd::AbstractDict: the simulation options dictionary.\ndata::VectoredDataset: the dataset to train and test on.\ndir_func::Function: the function that provides the correct file path with provided strings.\nopts::AbstractDict: additional options for the simulation.\n\nMethod List / Definition Locations\n\ntt_gramart(d, data, dir_func, opts)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/experiments.jl:105.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.tt_real-Tuple{Symbol}","page":"Dev Index","title":"OAR.tt_real","text":"tt_real(mldataset::Symbol; download_local) -> OAR.DataSplit\n\n\nSummary\n\nLoads the Iris dataset and returns a OAR.DataSplit.\n\nArguments\n\ndownload_local::Bool=false: optional (default false), to download the Iris dataset to the local datadir.\n\nMethod List / Definition Locations\n\ntt_real(mldataset; download_local)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/data_utils.jl:234.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.update_dist!-Tuple{ProtoNode, GSymbol{String}}","page":"Dev Index","title":"OAR.update_dist!","text":"update_dist!(pn::ProtoNode, symb::GSymbol{String})\n\n\nSummary\n\nUpdates the distribution of a single OAR.ProtoNode from one new symbol instance.\n\nArguments\n\npn::ProtoNode: the OAR.ProtoNode to update the distribution with.\nsymb::GramARTSymbol: the symbol instance to update the OAR.ProtoNode with.\n\nMethod List / Definition Locations\n\nupdate_dist!(pn, symb)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/functions.jl:130.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.vector_to_tree-Tuple{Vector{GSymbol{String}}, AbstractString}","page":"Dev Index","title":"OAR.vector_to_tree","text":"vector_to_tree(\n    local_vec::Vector{GSymbol{String}},\n    nonterminal::AbstractString\n) -> TreeNode\n\n\nSummary\n\nTurns a vector of GramARTSymbols into a nonterminal OAR.TreeNode with children.\n\nArguments\n\nlocal_vec::Vector{GramARTSymbol}: the vector to turn into a OAR.TreeNode.\nnonterminal::AbstractString: the nonterminal string name at the top of the tree.\n\nMethod List / Definition Locations\n\nvector_to_tree(local_vec, nonterminal)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/parsers/cmt.jl:257.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.weighted-Tuple{GramART, Bool}","page":"Dev Index","title":"OAR.weighted","text":"weighted(F2::GramART, activation::Bool)\n\n\nSummary\n\nWeighted linkage DDVFA similarity function.\n\nArguments:\n\nF2::GramART: the DDVSTART GramART F2 node to compute the linkage method within.\nactivation::Bool: flag to use the activation function. False uses the match function.\n\nMethod List / Definition Locations\n\nweighted(F2, activation)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/dv.jl:235.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.work_dir-Tuple","page":"Dev Index","title":"OAR.work_dir","text":"work_dir(args...) -> String\n\n\nSummary\n\nPoints to the work directory containing raw datasets, processed datasets, and results.\n\nArguments\n\nargs...: the string directories to append to the directory.\n\nMethod List / Definition Locations\n\nwork_dir(args)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/utils/drwatson.jl:20.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#dev-index-types-docs","page":"Dev Index","title":"Types","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"Modules = [OAR]\nPublic  = false\nOrder   = [:type]","category":"page"},{"location":"man/dev-index/#OAR.ARTNode","page":"Dev Index","title":"OAR.ARTNode","text":"abstract type ARTNode\n\nSummary\n\nDefinition of the ARTNode supertype.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.CFG","page":"Dev Index","title":"OAR.CFG","text":"struct CFG{U} <: OAR.Grammar{U}\n\nSummary\n\nContext-Free Grammar.\n\nConsists of a set of terminal symbols, non-terminal symbols, and production rules of Backus-Naur Form.\n\nFields\n\nN::Set{GSymbol{U}} where U: Non-terminal symbols of the grammar.\n\nT::Set{GSymbol{U}} where U: Terminal symbols of the grammar.\n\nS::Array{GSymbol{U}, 1} where U: Definition of a statement in this grammar.\n\nP::Dict{GSymbol{U}, Set{GSymbol{U}}} where U: The set of production rules of the grammar of the Backus-Naur Form (CFG).\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.CFG-Tuple{}","page":"Dev Index","title":"OAR.CFG","text":"Empty constructor for a Context-Free Grammar.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.CFG-Union{Tuple{Array{GSymbol{T}, 1}}, Tuple{T}} where T","page":"Dev Index","title":"OAR.CFG","text":"Constructor for a Context-Free Grammer with an initial statement of non-terminal symbols.\n\nArguments\n\nN::Statement: an initial set of non-terminal grammar symbols.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.CMTGramARTTree","page":"Dev Index","title":"OAR.CMTGramARTTree","text":"struct CMTGramARTTree <: Lerche.Transformer\n\nSummary\n\nThe CMT grammar tree subtypes from a Lerche Transformer.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.CMTPipedTree","page":"Dev Index","title":"OAR.CMTPipedTree","text":"struct CMTPipedTree <: Lerche.Transformer\n\nSummary\n\nPiped statements tree.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.CMTSymbol","page":"Dev Index","title":"OAR.CMTSymbol","text":"CMTSymbol\n\nDescription\n\nAlias stating that a CMT grammar symbol is a string (CMTSymbol =GSymbol{String}).\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.ConfigDict","page":"Dev Index","title":"OAR.ConfigDict","text":"ConfigDict\n\nDescription\n\nDefinition of a configuration dictionary loaded from a config file.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.DDVSTART","page":"Dev Index","title":"OAR.DDVSTART","text":"mutable struct DDVSTART\n\nSummary\n\nFields\n\nopts::OAR.opts_DDVSTART: DDVSTART options struct.\n\nsubopts::OAR.opts_GramART: START options struct used for all F2 nodes.\n\nF2::Vector{GramART}: List of F2 nodes (themselves GramART modules).\n\nlabels::Vector{Int64}: Incremental list of labels corresponding to each F2 node, self-prescribed or supervised.\n\nn_categories::Int64: Number of total categories.\n\nepoch::Int64: Current training epoch.\n\nT::Vector{Float64}: DDVFA activation values.\n\nM::Vector{Float64}: DDVFA match values.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.DataSplit","page":"Dev Index","title":"OAR.DataSplit","text":"struct DataSplit <: OAR.TTDataset\n\nSummary\n\nTrain/test split dataset.\n\nThis struct contains a standardized train/test split of real-valued vectors of samples arranged in a matrix and mapping to integered labels.\n\nFields\n\ntrain_x::Matrix{Float64}: The training data as a matrix of floating-point feature vectors: (n_features, n_samples).\n\ntest_x::Matrix{Float64}: The testing data as a matrix of floating-point feature vectors: (n_features, n_samples).\n\ntrain_y::Vector{Int64}: The training labels as a vector of integer labels: (n_samples,).\n\ntest_y::Vector{Int64}: The testing labels as a vector of integer labels: (n_samples,)\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.DataSplitGeneric","page":"Dev Index","title":"OAR.DataSplitGeneric","text":"struct DataSplitGeneric{T, U} <: OAR.VectoredDataset\n\nSummary\n\nGeneric train/test split dataset.\n\nThis struct contains a standardized train/test split of a vector of samples mapping to integered labels.\n\nFields\n\ntrain_x::Any: The training data as a vector of samples.\n\ntest_x::Any: The testing data as a vector of samples.\n\ntrain_y::Any: The training labels as a vector of integer labels: (n_samples,).\n\ntest_y::Any: The testing labels as a vector of integer labels: (n_samples,)\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.GramARTStatement","page":"Dev Index","title":"OAR.GramARTStatement","text":"GramARTStatement\n\nDescription\n\nDefinition of one statement used throughout GramART.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.GramARTStatements","page":"Dev Index","title":"OAR.GramARTStatements","text":"GramARTStatements\n\nDescription\n\nDefinition of statements used throughout GramART.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.GramARTStats","page":"Dev Index","title":"OAR.GramARTStats","text":"GramARTStats\n\nDescription\n\nType alias for the OAR.GramART dictionary containing module stats.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.GramARTSymbol","page":"Dev Index","title":"OAR.GramARTSymbol","text":"GramARTSymbol\n\nDescription\n\nDefinition of symbols used throughtout GramART.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.Grammar","page":"Dev Index","title":"OAR.Grammar","text":"abstract type Grammar{T}\n\nSummary\n\nAbstract type for formal grammars.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.IRISGramARTTree","page":"Dev Index","title":"OAR.IRISGramARTTree","text":"struct IRISGramARTTree <: Lerche.Transformer\n\nSummary\n\nThe IRIS grammar tree subtypes from a Lerche Transformer.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.IRISSymbol","page":"Dev Index","title":"OAR.IRISSymbol","text":"IRISSymbol\n\nDescription\n\nType alias stating that a symbolic IRIS dataset symbol is a string\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.KGGramARTTree","page":"Dev Index","title":"OAR.KGGramARTTree","text":"struct KGGramARTTree <: Lerche.Transformer\n\nSummary\n\nThe KG grammar tree subtypes from a Lerche Transformer.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.KGStatement","page":"Dev Index","title":"OAR.KGStatement","text":"KGStatement\n\nDescription\n\nAlias stating that KG statements are vectors of KG grammar symbols (KGStatement = Vector{[KGSymbol](@ref)}`).\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.KGSymbol","page":"Dev Index","title":"OAR.KGSymbol","text":"KGSymbol\n\nDescription\n\nAlias stating that a KG grammar symbol is a string (KGSymbol =GSymbol{String}).\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.ProductionRule","page":"Dev Index","title":"OAR.ProductionRule","text":"ProductionRule\n\nDescription\n\nType alias (ProductionRule{T} =OAR.SymbolSet{T}), a grammar production rule is a set of symbols.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.ProductionRuleSet","page":"Dev Index","title":"OAR.ProductionRuleSet","text":"ProductionRuleSet\n\nDescription\n\nType alias (ProductionRuleSet{T} = Dict{OAR.GSymbol{T},OAR.ProductionRule{T}}), a production rule set is a dictionary mapping grammar symbols to production rules.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.ProtoChildren","page":"Dev Index","title":"OAR.ProtoChildren","text":"ProtoChildren\n\nDescription\n\nAlias for how ProtoNode children are indexed (ProtoChildren = Dict{GramARTSymbol,ProtoNode}).\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.ProtoNodeStats","page":"Dev Index","title":"OAR.ProtoNodeStats","text":"mutable struct ProtoNodeStats\n\nSummary\n\nThe mutable components of a OAR.ProtoNode, containing options and statistics of the node.\n\nFields\n\nm::Int64: Convenience counter for the total number of symbols encountered.\n\nterminal::Bool: If the ProtoNode is terminal on the graph.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.ProtoNodeStats-Tuple{}","page":"Dev Index","title":"OAR.ProtoNodeStats","text":"ProtoNodeStats() -> OAR.ProtoNodeStats\n\n\nSummary\n\nEmpty constructor for the mutable options and stats component of a OAR.ProtoNode.\n\nMethod List / Definition Locations\n\nProtoNodeStats()\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/types.jl:387.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.Statement","page":"Dev Index","title":"OAR.Statement","text":"Statement\n\nDescription\n\nType alias (Statement{T} = Vector{OAR.GSymbol{T}}), a statement is a vector of grammar symbols.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.Statements","page":"Dev Index","title":"OAR.Statements","text":"Statements\n\nDescription\n\nType alias (Statements{T} = Vector{Statement{T}}), statements are a vector of the statement type.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.SymbolCount","page":"Dev Index","title":"OAR.SymbolCount","text":"SymbolCount\n\nDescription\n\nThe structure of the counter for symbols in a ProtoNode (SymbolCount = Dict{GramARTSymbol, Int}).\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.SymbolSet","page":"Dev Index","title":"OAR.SymbolSet","text":"SymbolSet\n\nDescription\n\nType alias (SymbolSet{T} = Set{OAR.GSymbol{T}}), a set of grammar symbols is implemented as a Julia set.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.TTDataset","page":"Dev Index","title":"OAR.TTDataset","text":"abstract type TTDataset\n\nSummary\n\nAbstract supertype for train/test split datasets\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.TerminalDist","page":"Dev Index","title":"OAR.TerminalDist","text":"TerminalDist\n\nDescription\n\nTerminal Distribution definition that is a dictionary mapping from terminal symbols to probabilities (TerminalDist = Dict{GramARTSymbol, Float}).\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.TreeStatement","page":"Dev Index","title":"OAR.TreeStatement","text":"TreeStatement\n\nDescription\n\n\"\" A TreeStatement is simply a TreeNode.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.TreeStatements","page":"Dev Index","title":"OAR.TreeStatements","text":"TreeStatements\n\nDescription\n\nMany TreeStatements are a Vector of TreeNodes.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.VectoredDataSplit","page":"Dev Index","title":"OAR.VectoredDataSplit","text":"struct VectoredDataSplit{T, M} <: OAR.VectoredDataset\n\nSummary\n\nVectored train/test split of arbitrary feature types.\n\nThis struct contains a standardized train/test split of vectors of vectored samples that map to labels.\n\nFields\n\ntrain_x::Array{Vector{T}, 1} where T: Training data as a vector of feature vectors of type T.\n\ntest_x::Array{Vector{T}, 1} where T: Testing data as a vector of feature vectors of type T.\n\ntrain_y::Vector: Training labels as a vector of type M.\n\ntest_y::Vector: Testing labels as a vector of type M.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.VectoredDataSplit-Tuple{OAR.DataSplit}","page":"Dev Index","title":"OAR.VectoredDataSplit","text":"Convenience constructor, turning a OAR.DataSplit into its vectored variant.\n\nArguments\n\ndata::DataSplit: the original OAR.DataSplit to transform into a vectored data ssplit.\n\n\n\n\n\n","category":"method"},{"location":"man/dev-index/#OAR.VectoredDataset","page":"Dev Index","title":"OAR.VectoredDataset","text":"abstract type VectoredDataset <: OAR.TTDataset\n\nSummary\n\nAbstract supertype for datasets that have vectored elements.\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.opts_GramART","page":"Dev Index","title":"OAR.opts_GramART","text":"mutable struct opts_GramART\n\nSummary\n\nGramART options struct as a Parameters.jl @with_kw object.\n\nFields\n\nrho::Float64: Vigilance parameter: ρ ∈ [0, 1]  Default: 0.7\nrho_lb::Float64: Lower-bound vigilance parameter: rho_lb ∈ [0, 1].  Default: 0.55\nrho_ub::Float64: Upper bound vigilance parameter: rho_ub ∈ [0, 1].  Default: 0.75\nalpha::Float64: Choice parameter: alpha > 0.  Default: 0.001\nbeta::Float64: Learning parameter: beta ∈ (0, 1].  Default: 1.0\nepochs::Int64: Maximum number of epochs during training.  Default: 1\nterminated::Bool: Flag for generating nodes at the terminal distributions below their nonterminal positions.  Default: false\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#dev-index-constants-docs","page":"Dev Index","title":"Constants","text":"","category":"section"},{"location":"man/dev-index/","page":"Dev Index","title":"Dev Index","text":"Modules = [OAR]\nPublic  = false\nOrder   = [:constant]","category":"page"},{"location":"man/dev-index/#OAR.ARG_ARGPARSE_DESCRIPTION","page":"Dev Index","title":"OAR.ARG_ARGPARSE_DESCRIPTION","text":"ARGARGPARSEDESCRIPTION\n\nDescription\n\nCommon docstring: the arguments to argparse functions taking a description.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.ARG_CFG","page":"Dev Index","title":"OAR.ARG_CFG","text":"ARG_CFG\n\nDescription\n\nCommon docstring: a CFG grammar argument.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.ARG_CONFIG_FILE","page":"Dev Index","title":"OAR.ARG_CONFIG_FILE","text":"ARGCONFIGFILE\n\nDescription\n\nCommon docstring: config filename argument.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.ARG_FILENAME","page":"Dev Index","title":"OAR.ARG_FILENAME","text":"ARG_FILENAME\n\nDescription\n\nCommon docstring: argument for a file name.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.ARG_SIM_D","page":"Dev Index","title":"OAR.ARG_SIM_D","text":"ARGSIMD\n\nDescription\n\nCommon docstring: argument for the simulation options dictionary.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.ARG_SIM_DIR_FUNC","page":"Dev Index","title":"OAR.ARG_SIM_DIR_FUNC","text":"ARGSIMDIR_FUNC\n\nDescription\n\nCommon docstring: argument for a directory function\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.ARG_SIM_OPTS","page":"Dev Index","title":"OAR.ARG_SIM_OPTS","text":"ARGSIMOPTS\n\nDescription\n\nCommon docstring: argument for additional simulation options.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.ARG_SIM_TS","page":"Dev Index","title":"OAR.ARG_SIM_TS","text":"ARGSIMTS\n\nDescription\n\nCommon docstring: argument for the simulation statements to train upon and cluster.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.CMT_CLUSTERING_COLUMNS","page":"Dev Index","title":"OAR.CMT_CLUSTERING_COLUMNS","text":"CMTCLUSTERINGCOLUMNS\n\nDescription\n\nA list of the feature columns used in clustering the CMT dataset\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.CMT_PHENOTYPES","page":"Dev Index","title":"OAR.CMT_PHENOTYPES","text":"CMT_PHENOTYPES\n\nDescription\n\nA list of the phenotype columns for aggregation into one GramART feature.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.COLORSCHEME","page":"Dev Index","title":"OAR.COLORSCHEME","text":"Plotting colorscheme.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.COMMON_DOC","page":"Dev Index","title":"OAR.COMMON_DOC","text":"COMMON_DOC\n\nDescription\n\nDocstring prefix denoting that the constant is used as a common docstring element for other docstrings.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.DEFAULT_N_PROCS_UNIX","page":"Dev Index","title":"OAR.DEFAULT_N_PROCS_UNIX","text":"The default number of processes to start in distributed experiments on Linux.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.DEFAULT_N_PROCS_WINDOWS","page":"Dev Index","title":"OAR.DEFAULT_N_PROCS_WINDOWS","text":"The default number of processes to start in distributed experiments on Windows.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.DPI","page":"Dev Index","title":"OAR.DPI","text":"The default plotting dots-per-inch for saving.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.DRWATSON_ARGS_DOC","page":"Dev Index","title":"OAR.DRWATSON_ARGS_DOC","text":"DRWATSONARGSDOC\n\nDescription\n\nCommon docstring: the arguments to DrWatson-style directory functions.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.FONTFAMILY","page":"Dev Index","title":"OAR.FONTFAMILY","text":"Plotting fontfamily for all text.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.GRAMMAR_ARG","page":"Dev Index","title":"OAR.GRAMMAR_ARG","text":"GRAMMAR_ARG\n\nDescription\n\nCommon docstring argument for grammars.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.GRAMMAR_SYMB_ARG","page":"Dev Index","title":"OAR.GRAMMAR_SYMB_ARG","text":"GRAMMARSYMBARG\n\nDescription\n\nCommon docstring for functions using a grammar and a grammar symbol.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.GSYMBOL_DATA_ARG","page":"Dev Index","title":"OAR.GSYMBOL_DATA_ARG","text":"GSYMBOLDATAARG\n\nDescription\n\nCommon argument docstring for GSymbol consruction.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.LINEWIDTH","page":"Dev Index","title":"OAR.LINEWIDTH","text":"Plotting linewidth.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.LINKAGE_METHODS","page":"Dev Index","title":"OAR.LINKAGE_METHODS","text":"LINKAGE_METHODS\n\nDescription\n\nA list of all distributed dual-vigilance similarity linkage methods.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.SAVE_MAP","page":"Dev Index","title":"OAR.SAVE_MAP","text":"SAVE_MAP\n\nDescription\n\nDictionary mapping the names of result save types to the private wrapper functions that implement them.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.SomeStatement","page":"Dev Index","title":"OAR.SomeStatement","text":"SomeStatement\n\nDescription\n\nAlias for arguments accepting multiple definitions of a statement formulation.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.SomeStatements","page":"Dev Index","title":"OAR.SomeStatements","text":"SomeStatements\n\nDescription\n\nAlias for arguments accepting multiple definitions of statement formulations.\n\n\n\n\n\n","category":"type"},{"location":"man/dev-index/#OAR.alphabet","page":"Dev Index","title":"OAR.alphabet","text":"alphabet\n\nDescription\n\nVector of alphabetical letters as Strings for discretized feature labels.\n\n\n\n\n\n","category":"constant"},{"location":"man/dev-index/#OAR.letter_vec","page":"Dev Index","title":"OAR.letter_vec","text":"letter_vec\n\nDescription\n\nTwo-letter alphabetical feature names.\n\n\n\n\n\n","category":"constant"},{"location":"man/full-index/#main-index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"This page lists the core functions and types of the Julia component of the OAR project.","category":"page"},{"location":"man/full-index/#index-toc","page":"Index","title":"\"Table\" of Contents","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules Functions Types Constants\nIndex Index Index Index\nDocs Docs Docs Docs","category":"page"},{"location":"man/full-index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"This section enumerates the names exported by the package, each of which links to its corresponding Documentation.","category":"page"},{"location":"man/full-index/#index-modules","page":"Index","title":"Modules","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages   = [\"full-index.md\"]\nModules = [OAR]\nOrder   = [:module]","category":"page"},{"location":"man/full-index/#index-functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages   = [\"full-index.md\"]\nModules = [OAR]\nOrder   = [:function]","category":"page"},{"location":"man/full-index/#index-types","page":"Index","title":"Types","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages   = [\"full-index.md\"]\nModules = [OAR]\nOrder   = [:type]","category":"page"},{"location":"man/full-index/#index-constants","page":"Index","title":"Constants","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Pages   = [\"full-index.md\"]\nModules = [OAR]\nOrder   = [:constant]","category":"page"},{"location":"man/full-index/#index-docs","page":"Index","title":"Docs","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"This section lists the documentation for every exported name of the OAR package.","category":"page"},{"location":"man/full-index/#index-modules-docs","page":"Index","title":"Modules","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [OAR]\nPrivate = false\nOrder   = [:module]","category":"page"},{"location":"man/full-index/#OAR.OAR","page":"Index","title":"OAR.OAR","text":"A module encapsulating the experimental driver code for the OAR project.\n\nImports\n\nThe following names are imported by the package as dependencies:\n\nAdaptiveResonance\nArgParse\nBase\nCSV\nCore\nDataFrames\nDelimitedFiles\nDistributed\nDocStringExtensions\nDrWatson\nInvertedIndices\nLerche\nMLDatasets\nMLUtils\nNumericalTypeAliases\nParameters\nPkg\nPlots\nProgressMeter\nRandom\nReexport\nStatsPlots\n\nExports\n\nThe following names are exported and available when using the package:\n\nGSymbol\nGramART\nOAR_VERSION\nProtoNode\nTreeNode\n\n\n\n\n\n","category":"module"},{"location":"man/full-index/#index-functions-docs","page":"Index","title":"Functions","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [OAR]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"man/full-index/#index-types-docs","page":"Index","title":"Types","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [OAR]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"man/full-index/#OAR.GSymbol","page":"Index","title":"OAR.GSymbol","text":"struct GSymbol{T}\n\nSummary\n\nDefinition of a grammar symbol with arbitrary datatype and a boolean flag for if the symbol is terminal or not.\n\nFields\n\ndata::Any: The grammar symbol of type T.\n\nterminal::Bool: Boolean flag if the symbol is terminal (true) or nonterminal (false).\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#OAR.GSymbol-Tuple{T} where T","page":"Index","title":"OAR.GSymbol","text":"Constructor for a grammar symbol from just the provided data (defaults to being terminal).\n\nArguments\n\ndata::T where T <: Any: the piece of data comprising the grammar symbol of any type.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#OAR.GramART","page":"Index","title":"OAR.GramART","text":"struct GramART\n\nSummary\n\nDefinition of a GramART module.\n\nContains the ProtoNodes and CFG grammar that is used for processing statements and generating nodes.\n\nFields\n\nprotonodes::Vector{ProtoNode}: The OAR.ProtoNodes of the GramART module.\n\ngrammar::OAR.CFG: The OAR.CFG (Context-Free Grammar) used for processing data (statements).\n\nopts::OAR.opts_GramART: The OAR.opts_GramART hyperparameters of the GramART module.\n\nlabels::Vector{Int64}: Incremental list of labels corresponding to each F2 node, self-prescribed or supervised.\n\nT::Vector{Float64}: Activation values for every weight for a given sample.\n\nM::Vector{Float64}: Match values for every weight for a given sample.\n\nstats::Dict{String, Any}: Dictionary of mutable statistics for the module.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#OAR.GramART-Tuple{OAR.CFG, OAR.opts_GramART}","page":"Index","title":"OAR.GramART","text":"GramART(grammar::OAR.CFG, opts::OAR.opts_GramART) -> GramART\n\n\nSummary\n\nConstructor for an OAR.GramART module that takes a CFG grammar and automatically sets up the ProtoNode tree.\n\nArguments\n\ngrammar::CFG: the [OAR.CFG] context-free grammar to use.\nopts::opts_GramART: a custom set of OAR.GramART options to use.\n\nMethod List / Definition Locations\n\nGramART(grammar, opts)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/types.jl:347.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#OAR.GramART-Tuple{OAR.CFG}","page":"Index","title":"OAR.GramART","text":"GramART(grammar::OAR.CFG; kwargs...) -> GramART\n\n\nSummary\n\nConstructor for an OAR.GramART module that takes a OAR.CFG grammar and an optional list of keyword arguments for the options.\n\nArguments\n\ngrammar::CFG: the [OAR.CFG] context-free grammar to use.\nkwargs...: a list of keyword arguments for the OAR.opts_GramART options struct.\n\nMethod List / Definition Locations\n\nGramART(grammar; kwargs...)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/types.jl:373.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#OAR.ProtoNode","page":"Index","title":"OAR.ProtoNode","text":"struct ProtoNode <: OAR.ARTNode\n\nSummary\n\nProtoNode struct, used to generate tree prototypes, which are the templates of OAR.GramART.\n\nFields\n\ndist::Dict{GSymbol{String}, Float64}: The TerminalDist distribution over all symbols at this node.\n\nN::Dict{GSymbol{String}, Int64}: The SymbolCount update counters for each symbol.\n\nchildren::Dict{GSymbol{String}, ProtoNode}: The children of this node (Dict{GramARTSymbol, ProtoNode}).\n\nstats::OAR.ProtoNodeStats: The mutable ProtoNodeStats options and stats of the ProtoNode.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#OAR.ProtoNode-Tuple{Set{GSymbol{T}} where T}","page":"Index","title":"OAR.ProtoNode","text":"ProtoNode(symbols::Set{GSymbol{T}} where T) -> ProtoNode\n\n\nSummary\n\nConstructor for a zero-initialized OAR.GramART OAR.ProtoNode.\n\nArguments\n\nsymbols::SymbolSet: the terminal symbols to initialize the node with.\n\nMethod List / Definition Locations\n\nProtoNode(symbols)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/types.jl:414.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#OAR.ProtoNode-Tuple{}","page":"Index","title":"OAR.ProtoNode","text":"ProtoNode() -> ProtoNode\n\n\nSummary\n\nEmpty constructor for a OAR.GramART OAR.ProtoNode.\n\nMethod List / Definition Locations\n\nProtoNode()\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/types.jl:398.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#OAR.TreeNode","page":"Index","title":"OAR.TreeNode","text":"struct TreeNode <: OAR.ARTNode\n\nSummary\n\nTree node for a GramART module.\n\nFields\n\nt::GSymbol{String}: The GramARTSymbol symbol for the node.\n\nchildren::Vector{TreeNode}: Children nodes of this node.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#OAR.TreeNode-2","page":"Index","title":"OAR.TreeNode","text":"TreeNode(name::AbstractString) -> TreeNode\nTreeNode(\n    name::AbstractString,\n    is_terminal::Bool\n) -> TreeNode\n\n\nSummary\n\nConstructor for a OAR.GramART OAR.TreeNode, taking a string name of the symbol and if it is terminal or not.\n\nArguments\n\nname::AbstractString: the string name of the symbol to instantiate the OAR.TreeNode with.\nis_terminal::Bool: flag for if the symbol in the node is terminal or not.\n\nMethod List / Definition Locations\n\nTreeNode(name)\nTreeNode(name, is_terminal)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/types.jl:448.\n\n\n\n\n\n","category":"type"},{"location":"man/full-index/#OAR.TreeNode-Tuple{GSymbol{String}}","page":"Index","title":"OAR.TreeNode","text":"TreeNode(symb::GSymbol{String}) -> TreeNode\n\n\nSummary\n\nConstructor for a OAR.GramART OAR.TreeNode taking an existing OAR.GramARTSymbol.\n\nArguments\n\nsymb::GramARTSymbol: the preconstructed GramARTSymbol used for constructing the OAR.TreeNode.\n\nMethod List / Definition Locations\n\nTreeNode(symb)\n\ndefined at /home/runner/work/OAR/OAR/src/lib/gramart/types.jl:434.\n\n\n\n\n\n","category":"method"},{"location":"man/full-index/#index-constants-docs","page":"Index","title":"Constants","text":"","category":"section"},{"location":"man/full-index/","page":"Index","title":"Index","text":"Modules = [OAR]\nPrivate = false\nOrder   = [:constant]","category":"page"},{"location":"man/full-index/#OAR.OAR_VERSION","page":"Index","title":"OAR.OAR_VERSION","text":"A constant that contains the version of the installed OAR package.\n\nThis value is computed at compile time, so it may be used to programmatically verify the version of OAR that is installed in case a compat entry in your Project.toml is missing or otherwise incorrect.\n\n\n\n\n\n","category":"constant"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using OAR, Dates\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/logo.png\" width=\"300\">","category":"page"},{"location":"#OAR","page":"Home","title":"OAR","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"These pages serve as the official documentation for the OAR (Ontologies with Adaptive Resonance) project.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The OAR project is a development workspace for experiments targeting ontologies and knowledge graphs with Adaptive Resonance Theory (ART) algorithms. Due to the broad nature of the research, many tools and types of experiments are involved, from medical ontologies to NLP parsing with tokenizers and deep model embeddings. As a result, please see the relevant documentation sections about the various programming languages, tools, and experiments involved throughout the repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This repository is developed and maintained by Sasha Petrenko <petrenkos@mst.edu> on behalf of the Missouri University of Science and Technology (MS&T) Applied Computational Intelligence Laboratory (ACIL).","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation is split into the following sections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/guide.md\",\n    \"../examples/index.md\",\n    \"man/languages.md\",\n    \"man/contributing.md\",\n    \"man/full-index.md\",\n    \"man/dev-index.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Package Guide provides a tutorial to the full usage of the package, while Examples gives sample workflows with the various experiments of the project.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Because there are components to this project implemented in other programming languages, the Languages section outlines various other usages in the project outside of the Julia components and structure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Contributing section outlines how to contribute to the project. The Index enumerates all public types, functions, and other components with docstrings, whereas internals are listed in the Developer's Index.","category":"page"},{"location":"#About-These-Docs","page":"Home","title":"About These Docs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Though several different programming languages are used throughout the project, these docs are built around the Julia component of the project using the Documenter.jl package.","category":"page"},{"location":"#Documentation-Build","page":"Home","title":"Documentation Build","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation was built using Documenter.jl with the following version and OS:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OAR, Dates # hide\nprintln(\"OAR v$(OAR_VERSION) docs built $(Dates.now()) with Julia $(VERSION) on $(Sys.KERNEL)\") # hide","category":"page"}]
}
